<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ABC #215</title>
    <url>/2021/08/22/ABC-215/</url>
    <content><![CDATA[<h2 id="atcoder-beginner-contest-215"><a
href="https://atcoder.jp/contests/abc215">AtCoder Beginner Contest
215</a></h2>
<h4 id="f---dist-max-2"><a
href="https://atcoder.jp/contests/abc215/tasks/abc215_f">F - Dist Max
2</a></h4>
<p>Approach: binary search</p>
<p>Binary Search is always an option! Unless you have to do things the
hardest way.</p>
<h4 id="g---colorful-candies-2"><a
href="https://atcoder.jp/contests/abc215/tasks/abc215_g">G - Colorful
Candies 2</a></h4>
<p>Split the expectation into <strong>contribution over each
color</strong>, then we have:</p>
<p><span class="math display">\[
\begin{aligned}
E(X_k) = \sum_{c}1 - \binom{n- cnt_c}{k} \left.  \middle / \binom{n}{k}
\right.
\end{aligned}
\]</span></p>
<p>Notice that there are at most <span
class="math inline">\(O(\sqrt{n})\)</span> different <span
class="math inline">\(cnt_c\)</span>. So the problem is solved in <span
class="math inline">\(O(n\sqrt n)\)</span> time.</p>
<h4 id="h---cabbage-master"><a
href="https://atcoder.jp/contests/abc215/tasks/abc215_h">H - Cabbage
Master</a></h4>
<p><a
href="https://en.wikipedia.org/wiki/Hall&#39;s_marriage_theorem">Hall's
marriage theorem</a></p>
<p>let <span class="math inline">\(O\)</span> be the set of all "1
cabbage order"<span class="math inline">\((ord, V)\)</span> where <span
class="math inline">\(V\)</span> is the set of all acceptable
brands.</p>
<p>By Hall’s marriage theorem, all the orders in set <span
class="math inline">\(O\)</span> can be satisfied if and only if</p>
<blockquote>
<p>for all <span class="math inline">\(T \subseteq O\)</span> , <span
class="math inline">\(\sum_{s\in \cup V}a_s \ge |T|\)</span> holds.</p>
</blockquote>
<p>change the summation order and iterate over set of brands, we
have</p>
<p><span class="math display">\[
f(S) \ge g(S)
\]</span></p>
<p>for all <span class="math inline">\(S \subseteq V\)</span> .</p>
<p>Where <span class="math inline">\(f(S)\)</span> is number of
cabbages, <span class="math inline">\(g(S)\)</span> is number of
orders.</p>
<p><span class="math inline">\(\min {(f(S) - g(S))}\)</span> is the
number of cabbages eaten.</p>
<p>Find all valid <span class="math inline">\(S\)</span>, and calculate
the number of ways when the snake only eats cabbages of brands in <span
class="math inline">\(S\)</span>.</p>
<p>This can be done using an OR convolution and an inverse AND
convolution.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">binom_init</span>();</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="built_in">FOR</span>(i, <span class="number">0</span>, n) a[i] = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="built_in">FOR</span>(i, <span class="number">0</span>, m) b[i] = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="built_in">FOR</span>(i, <span class="number">0</span>, n) <span class="built_in">FOR</span>(j, <span class="number">0</span>, m) c[i][j] = <span class="built_in">rd</span>();</span><br><span class="line">  <span class="built_in">FOR</span>(i, <span class="number">0</span>, <span class="number">1</span> &lt;&lt; n) <span class="built_in">FOR</span>(j, <span class="number">0</span>, n) f[i] += ((i &amp; (<span class="number">1</span> &lt;&lt; j)) != <span class="number">0</span>) * a[j];</span><br><span class="line">  <span class="built_in">FOR</span>(i, <span class="number">0</span>, m) &#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ROF</span>(j, <span class="number">0</span>, n) t = (t &lt;&lt; <span class="number">1</span>) | c[j][i];</span><br><span class="line">    g[t] += b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fwt</span>(g, <span class="number">1</span> &lt;&lt; n);</span><br><span class="line">  <span class="keyword">int</span> X = <span class="number">1e9</span>;</span><br><span class="line">  <span class="built_in">FOR</span>(i, <span class="number">0</span>, <span class="number">1</span> &lt;&lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (g[i]) <span class="built_in">chkmin</span>(X, f[i] - g[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (X &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;0 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">FOR</span>(i, <span class="number">0</span>, <span class="number">1</span> &lt;&lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (g[i] &amp;&amp; f[i] - g[i] == X) flag[i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fmt</span>(flag, <span class="number">1</span> &lt;&lt; n);</span><br><span class="line">  <span class="built_in">FOR</span>(i, <span class="number">0</span>, <span class="number">1</span> &lt;&lt; n) h[i] = <span class="built_in">binom</span>(f[i], X + <span class="number">1</span>);</span><br><span class="line">  ifwt(h, <span class="number">1</span> &lt;&lt; n);</span><br><span class="line">  <span class="function">mint <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="built_in">FOR</span>(i, <span class="number">0</span>, <span class="number">1</span> &lt;&lt; n) <span class="keyword">if</span> (flag[i]) ans += h[i];</span><br><span class="line">  cout &lt;&lt; X + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AtCoder rounds</category>
      </categories>
  </entry>
  <entry>
    <title>AtCoder Beginner Contest 217</title>
    <url>/2021/09/06/ABC-217/</url>
    <content><![CDATA[<h2 id="atcoder-beginner-contest-217">AtCoder Beginner Contest 217</h2>
<p>Easiest ABC ever!</p>
<h3 id="h---snuketoon"><a
href="https://atcoder.jp/contests/abc217/tasks/abc217_h">H -
Snuketoon</a></h3>
<p>考虑维护最小伤害的函数<span class="math inline">\(f_n(x)\)</span></p>
<p><span class="math display">\[
f_i(x) = \underset{x-\Delta t \leq x_0 \leq x + \Delta t} {\min}
f_{i-1}(x_0) + g_i(x)
\]</span></p>
<p>该函数为分段一次函数，且满足凸性，用<code>multiset</code>或者堆维护分段斜率即可。</p>
]]></content>
      <categories>
        <category>AtCoder rounds</category>
      </categories>
      <tags>
        <tag>Convex Hull</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Beginner Contest 221</title>
    <url>/2021/10/07/ABC-221/</url>
    <content><![CDATA[<h1 id="atcoder-beginner-contest-221">AtCoder Beginner Contest 221</h1>
<h3 id="g---jumping-sequence"><a
href="https://atcoder.jp/contests/abc221/tasks/abc221_g">G - Jumping
sequence</a></h3>
<p>坐标轴旋转<span
class="math inline">\(45^\circ\)</span>，转化为2个01背包。</p>
<h3 id="h---count-multiset"><a
href="https://atcoder.jp/contests/abc221/tasks/abc221_h">H - Count
Multiset</a></h3>
<p>差分数列计数+前缀和优化</p>
<p>差分前：</p>
<p><span class="math display">\[
f_{n,k}\leftarrow f_{n-ci,k-i}
\]</span></p>
<p>差分后：</p>
<p><span class="math display">\[
g_{k,s}\leftarrow_{i\lt m} g_{k-i,s-kj}
\]</span></p>
]]></content>
      <categories>
        <category>AtCoder rounds</category>
      </categories>
  </entry>
  <entry>
    <title>AGC problems</title>
    <url>/2021/10/30/AGC-problems/</url>
    <content><![CDATA[<h1 id="problem-c">Problem C</h1>
<h3 id="agc038-c---lcms"><a
href="https://atcoder.jp/contests/agc038/tasks/agc038_c">AGC038 C -
LCMs</a></h3>
<p>如果没有现成的数论函数来完成容斥，可以自己造一个！</p>
<p>let</p>
<p><span class="math display">\[
\frac1n=\sum_{d|n}{f(d)}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\textrm{lcm}{(x, y)} =&amp;\ \frac{xy}{\gcd(x,y)} \\
=&amp;\ xy\sum_{d|x,y}{f(d)}
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\mathrm{ans}(i)=\sum_{d|a_i}f(d)\sum_{j&lt;i}a_j[d\ |\ a_j]
\]</span></p>
<h3 id="agc040-c---neither-ab-nor-ba"><a
href="https://atcoder.jp/contests/agc040/tasks/agc040_c">AGC040 C -
Neither AB nor BA</a></h3>
<p>将奇数位上<span class="math inline">\(A\rightarrow
B\)</span>,将不能选<span class="math inline">\(AB\
BA\)</span>转换成不能选<span class="math inline">\(AA\ BB\)</span>。</p>
<p>结论：<span class="math inline">\(A\)</span>, <span
class="math inline">\(B\)</span>各不能超过一半。</p>
<h3 id="agc041-c---domino-quality"><a
href="https://atcoder.jp/contests/agc041/tasks/agc041_c">AGC041 C -
Domino Quality</a></h3>
<p>大构造，人工智能。</p>
<h3 id="agc035-c---skolem-xor-tree"><a
href="https://atcoder.jp/contests/agc035/tasks/agc035_c">AGC035 C -
Skolem XOR Tree</a></h3>
<p>大构造x2</p>
<p>根据样例提示，有<span
class="math inline">\(\bigoplus_{i=1}^{2^k-1}i=1\)</span>。</p>
<p>对于<span class="math inline">\(n=2^k\)</span>，只有一个第<span
class="math inline">\(k\)</span>位出现，显然-1.</p>
<p>对于<span class="math inline">\(n \&amp;1\)</span>，将大于<span
class="math inline">\(2^{\mathrm{31-clz(n)}}-1\)</span>的部分按<span
class="math inline">\((2k,2k+1)\)</span>分组。</p>
<p>对于<span class="math inline">\(n \&amp;
1=0\)</span>，特判前三个数，其余类似处理。</p>
]]></content>
  </entry>
  <entry>
    <title>AGC001</title>
    <url>/2021/10/09/AGC001/</url>
    <content><![CDATA[<h1 id="atcoder-grand-contest-001"><a
href="https://atcoder.jp/contests/agc001">AtCoder Grand Contest
001</a></h1>
<h3 id="problem-e"><a
href="https://atcoder.jp/contests/agc001/tasks/agc001_e">Problem
E</a></h3>
<p>由于每个<span class="math inline">\((i,
j)\)</span>对答案的贡献是<span
class="math inline">\(a_i+b_i+a_j+b_j\choose
a_i\)</span>,立即考虑单调路径模型。</p>
<p>发现贡献可以看作<span class="math inline">\((-a_i, -b_i)
\rightarrow(a_j, b_j)\)</span>。</p>
<p>由于值域只有<span class="math inline">\(2e4\)</span>,
直接对所有从第三象限到第一象限的路径DP即可。</p>
<h3 id="f---wide-swap"><a
href="https://atcoder.jp/contests/agc001/tasks/agc001_f">F - Wide
Swap</a></h3>
<p>通过计算pos数组，操作被转化为<span class="math inline">\(swap(pos_i,
pos_{i+1})\)</span>仅当<span class="math inline">\(|pos_i-pos_{i+1}|\ge
K\)</span>， 要求<span
class="math inline">\(1,2,\ldots,n\)</span>贪心地在pos最前。</p>
<p>显然，<span class="math inline">\(|pos_i-pos_j|\lt K\)</span>的<span
class="math inline">\((i, j)\)</span>顺序不变。对所有这样的<span
class="math inline">\((i,j)\)</span>从i向j连边，形成DAG。</p>
<p>答案即是字典序最小的拓扑排序。</p>
<p>考虑贪心地对没有出边的最大的点赋予更大的序号，这样的<span
class="math inline">\(i\)</span>满足<span
class="math inline">\(P_i=\underset{i-K+1\le j\le i+K-1}
{\operatorname{argmax}} P_j\)</span>。</p>
<p><code>priority_queue</code> + 线段树RMQ。<span
class="math inline">\(O(n\log n)\)</span></p>
]]></content>
      <categories>
        <category>AGC Series</category>
      </categories>
  </entry>
  <entry>
    <title>AGC002</title>
    <url>/2021/10/14/AGC002/</url>
    <content><![CDATA[<h1 id="atcoder-grand-contest-002---atcoder"><a
href="https://atcoder.jp/contests/agc002">AtCoder Grand Contest 002 -
AtCoder</a></h1>
<h3 id="d---stamp-rally"><a
href="https://atcoder.jp/contests/agc002/tasks/agc002_d">D - Stamp
Rally</a></h3>
<p>通过BFS形态的整体二分，实现数据结构中只用维护加边操作。<span
class="math inline">\(O(n\log n *DSU)\)</span></p>
<h3 id="e---candy-piles"><a
href="https://atcoder.jp/contests/agc002/tasks/agc002_e">E - Candy
Piles</a></h3>
<p>建立网格图，发现两个操作分别是删一行和删一列。</p>
<h3 id="f---leftmost-ball"><a
href="https://atcoder.jp/contests/agc002/tasks/agc002_f">F - Leftmost
Ball</a></h3>
<p>不妨规定颜色出现顺序为<span class="math inline">\(1\rightarrow
n\)</span>省去容斥的麻烦。</p>
<p>将问题转化为拓扑序计数进行DP。</p>
]]></content>
      <categories>
        <category>AGC Series</category>
      </categories>
      <tags>
        <tag>multi-query binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC003</title>
    <url>/2021/12/25/AGC003/</url>
    <content><![CDATA[<h1 id="atcoder-grand-contest-003">AtCoder Grand Contest 003</h1>
<h2 id="d---anticube">D - Anticube</h2>
<ol type="1">
<li>直接将每个数的立方因子去掉,作为代表元素. <span
class="math inline">\(O(A^{\frac13}/\ln A)\)</span></li>
<li>每个集合与其互补集合之间只能选择1个.</li>
<li>如何寻找互补集合?
<ul>
<li>对于<span class="math inline">\(p^3 \le
10^{10}\)</span>的因子,暴力处理.</li>
<li>剩下的部分只能是<span class="math inline">\(p\)</span>,<span
class="math inline">\(p^2\)</span>或<span
class="math inline">\(pq\)</span>形式, 查表.</li>
</ul></li>
</ol>
<h2 id="e---sequential-operations-on-sequence">E - Sequential operations
on Sequence</h2>
<ol type="1">
<li>首先<span class="math inline">\(\{a_n\}\)</span>可以变成单调栈.</li>
<li>考虑倒着处理问题, 每次把后缀加回前缀,
最后得到的数列就是每个数字的出现次数.</li>
<li>实现显然 <span class="math inline">\(O(Q\log Q\log N)\)</span></li>
</ol>
<h2 id="f---fraction-of-fractal">F - Fraction of Fractal</h2>
]]></content>
      <categories>
        <category>AGC Series</category>
      </categories>
      <tags>
        <tag>reversal</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC004</title>
    <url>/2021/12/25/AGC004/</url>
    <content><![CDATA[<h1 id="atcoder-grand-contest-004">AtCoder Grand Contest 004</h1>
<h2 id="c---and-grid">C - AND Grid</h2>
<p>构造. ## D - Teleporter 图论构造, 结论显然. ## E - Salvage Robots
考虑移动<code>Exit</code>点和边界, 分析性质, 设计<code>DP</code>. ## F -
Namori</p>
]]></content>
      <categories>
        <category>AGC Series</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC005</title>
    <url>/2021/12/25/AGC005/</url>
    <content><![CDATA[<h1 id="atcoder-grand-contest-005">AtCoder Grand Contest 005</h1>
<h2 id="d---k-perm-counting">D - ~K Perm Counting</h2>
<p>通过容斥(二项式反演), 最后变成了多条链上的独立集问题. ## E - Sugigma:
The Showdown 经典博弈论找结论做法. 1. 找到不合法条件 2. <span
class="math inline">\(\Delta\)</span>想办法把结论作为条件带回去继续做.
3. 此题将得到<code>Sigma</code>永远在子树内活动的结论.</p>
<h2 id="f---many-easy-problems">F - Many Easy Problems</h2>
<p>用虚数结论推一年, 算边的贡献一步做完...</p>
]]></content>
      <categories>
        <category>AGC Series</category>
      </categories>
      <tags>
        <tag>fft</tag>
        <tag>games</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC007</title>
    <url>/2022/01/20/AGC007/</url>
    <content><![CDATA[<h1 id="atcoder-grand-contest-003">AtCoder Grand Contest 003</h1>
<h2 id="c---pushing-balls">C - Pushing Balls</h2>
<p>期望是可以迭代的.
推式子可以发现第一步操作以后的期望距离序列依然是等差数列,于是递归.</p>
<h2 id="d---shik-and-game">D - Shik and Game</h2>
<p>单调队列优化DP ## E - Shik and Travel
二分+<code>DP</code>,将严格不优的状态去掉就能做到<span
class="math inline">\(O(n\log n)\)</span>的状态数.</p>
]]></content>
      <categories>
        <category>AGC Series</category>
      </categories>
  </entry>
  <entry>
    <title>AGC006</title>
    <url>/2022/01/20/AGC006/</url>
    <content><![CDATA[<h1 id="atcoder-grand-contest-006">AtCoder Grand Contest 006</h1>
<h2 id="c---rabbit-exercise">C - Rabbit Exercise</h2>
<p>推式子发现该操作就是把坐标差分的期望序列中相邻两项互换, 于是做完. ##
D - Median Pyramid Hard 看到排列, 并且与排序相关,
显然二分答案变成01序列做. ## E - Rotate 3x3 首先发现每一列都一定是<span
class="math inline">\(\{3k,3k+1,3k+2\}\)</span>,并且奇偶列之间不会交换.
于是变成了分奇数与偶数列的冒泡排序问题, 同时需要考虑每一列的方向变化.
### 法一 直接模拟冒泡排序, 计算每一列拍完序的方向. 时间<span
class="math inline">\(O(n\log n)\)</span>, 实现繁琐. ### 法二
题解的神仙做法.
如果分别计数不考虑方向合法性的合法序列个数与实际合法的序列数(暴搜),
发现正好是4倍关系, 这隐含着两组对称性. 考虑以偶数列为中心的操作,
每次既改变了奇数列排列的奇偶性, 也改变偶数列反方向列个数的奇偶性.
于是计算排列的奇偶性和反向列的个数对比即可判定合法性. ## F - Blackout
神仙题! 首先手玩几个数据, 将发现可以连的边与<span
class="math inline">\((d(x,z)\mod 3)\)</span>有关. 如果把图3-染色,
发现每个点只能与下一个颜色的点连边. 对于一个弱连通块, 存在如下结论: 1.
如果不存在<span class="math inline">\((x,y), (y,z)\)</span>,
显然不能连边. 2. 如果可以3-染色, 则两种相邻颜色的所有点之间都可以连边.
(可以不断进行迭代, 最后每一组边都一定可以被两个相邻的边表示出来) 3.
如果不能3-染色, 则任意点之间都可以连边.
(考虑一定存在环长不为3的倍数的环, 不断分割就可以得到自环, 由于弱联通,
可以从自环出发, 得到它与所以点组成的二元环, 最终得到所有的自环,
就可以构造任意边了)</p>
<p>于是把图划分连通块染色即可.</p>
]]></content>
      <categories>
        <category>AGC Series</category>
      </categories>
      <tags>
        <tag>permutations</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC134</title>
    <url>/2022/01/31/ARC134/</url>
    <content><![CDATA[<h1 id="atcoder-regular-contest-134"><a
href="https://atcoder.jp/contests/arc134">AtCoder Regular Contest
134</a></h1>
<h2 id="e---modulo-nim"><a
href="https://atcoder.jp/contests/arc134/tasks/arc134_e">E - Modulo
Nim</a></h2>
<p>现考虑<span class="math inline">\(m=2,3,4\)</span>的情况,
发现必败局面要么是<span class="math inline">\(\{a:a\in
A\}=\{4,8\}\)</span>, 要么所有的数都是<span
class="math inline">\(12\)</span> 的倍数. 因为值域很小<span
class="math inline">\(a_i\le 200\)</span> , 可以直接暴搜.</p>
<p>(赛时没有推出<span class="math inline">\(m=3\)</span>的情况,
没有利用值域性质)</p>
<h2 id="f---flipping-coins"><a
href="https://atcoder.jp/contests/arc134/tasks/arc134_f">F - Flipping
Coins</a></h2>
<ol type="1">
<li><p>发现操作对环独立(ok)</p></li>
<li><p><span
class="math inline">\(\Delta\)</span>考虑到如果把环拆成若干个递增的区间,
则每个偶数长的区间全部覆盖, 奇数长的区间会空出第一个位置.
于是答案就是奇数长度区间的数量.</p></li>
</ol>
]]></content>
      <categories>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>searching</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC040</title>
    <url>/2022/02/20/AGC040/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>AtCoder Beginner Contest 231</title>
    <url>/2021/12/13/AtCoder-Beginner-Contest-231/</url>
    <content><![CDATA[<h1
id="panasonic-programming-contest-2021atcoder-beginner-contest-231"><a
href="https://atcoder.jp/contests/abc231">Panasonic Programming Contest
2021(AtCoder Beginner Contest 231)</a></h1>
<h2 id="e.-minimal-payments"><a
href="https://atcoder.jp/contests/abc231/tasks/abc231_e">E. Minimal
payments</a></h2>
<p>Easy digit DP practice.</p>
<h2 id="g.-balls-in-boxes"><a
href="https://atcoder.jp/contests/abc231/tasks/abc231_g">G. Balls in
Boxes</a></h2>
<p>Consider the <code>Multivariable PGF</code> of this problem:</p>
<p><span class="math display">\[
f=\frac{1}{n^k}\prod x_i^{A_i}\left(\sum x_i\right)^k
\]</span></p>
<p>The term of the score, which is <span class="math inline">\(\prod
_{i=1}^NB_i\)</span>, immediately implies the answer to the problem.</p>
<p><span class="math display">\[
E(score)=\left[ \frac{\partial^N f}{\partial x_1\partial
x_2\dots\partial x_N}
\right ]_{x_i=1}
\]</span></p>
<p>We can notice that</p>
<p><span class="math display">\[
\frac{\partial }{\partial x_i}x_i^{m_i}\prod_{j\not=i} x_j^{m_j}
\left(\sum x_i\right)^k
=m_ix_i^{m_i-1}\prod_{j\not=i} x_j^{m_j}\left(\sum
x_i\right)^k+kx_i^{m_i}\prod_{j\not=i} x_j^{m_j} \left(\sum
x_i\right)^{k-1}
\]</span></p>
<p>Let <code>coef[n]</code> be the coefficient of <span
class="math inline">\(\prod x_i^{c_i}\left(\sum x_i\right)^n\)</span>,
we can easily process the partial derivative by an <span
class="math inline">\(O(n^2)\)</span> <code>DP</code>.</p>
<p><a
href="https://atcoder.jp/contests/abc231/submissions/27876075">submission</a></p>
<h2 id="h.-minimum-coloring"><a
href="https://atcoder.jp/contests/abc231/tasks/abc231_h">H. Minimum
Coloring</a></h2>
<p>The problem can be easily reduced to a weighted minimum edge cover
problem on a bipartite graph.</p>
<p>Let's first choose the minimum cost at each vertices, and let it be
<span class="math inline">\(C_u\)</span>.</p>
<p>Now we change the weight of each edge<span class="math inline">\((u,
v, w)\)</span> to <span
class="math inline">\(w&#39;=w-C_u-C_v\)</span>.</p>
<p>The answer should be <span class="math inline">\(\sum C_u-\)</span>
minimum cost matching of the resulting graph.</p>
<p>Since the new graph now have negative cost edges, we can solve the
problem as follows: (from AtCoder editorial)</p>
<blockquote>
<p>add a constant to make all weight positive, and subtract it
accordingly on the minimum cost slope.</p>
</blockquote>
<blockquote>
<p>Alternatively, we may add an edge from S to T with capacity min(H,W)
and cost BIG and find the minimum cost of flow min(H,W) to find the
answer in the same way.</p>
</blockquote>
]]></content>
      <categories>
        <category>ABC</category>
      </categories>
      <tags>
        <tag>min-cost-flow</tag>
        <tag>weighted-minimum-edge-cover</tag>
        <tag>MGF</tag>
      </tags>
  </entry>
  <entry>
    <title>About</title>
    <url>/2021/08/16/About/</url>
    <content><![CDATA[<p>An archive of my problem-solving/contests logs and notes, hosted
preliminary for future references.</p>
]]></content>
  </entry>
  <entry>
    <title>AtCoder Regular Contest 131</title>
    <url>/2021/12/06/AtCoder-Regular-Contest-131/</url>
    <content><![CDATA[<h1 id="atcoder-regular-contest-131"><a
href="https://atcoder.jp/contests/arc131">AtCoder Regular Contest
131</a></h1>
<h2 id="c.-zero-xor"><a
href="https://atcoder.jp/contests/arc131/tasks/arc131_c">C. Zero
XOR</a></h2>
<p>结论：</p>
<ol type="1">
<li><p><span class="math inline">\(2\not|n\)</span>时，必胜。</p></li>
<li><p><span class="math inline">\(2|n\)</span>时，若存在<span
class="math inline">\(XORSUM=A_i\)</span>，则必胜，否则必败。</p></li>
</ol>
<p>证明：</p>
<p>只需证明1即可。</p>
<p>转化：证明1，只需证明<span
class="math inline">\(n\)</span>为奇数时，游戏不会在恰好2次操作后结束。</p>
<p>若游戏在两轮后一定结束，则<span class="math inline">\(\forall A_i,
\exists A_{p_i}\ s.t.\ S \oplus A_i \oplus A_{p_i}=0\)</span></p>
<p>则所有<span class="math inline">\((i,p_i)\)</span>组成<span
class="math inline">\(n/2\)</span> 组。而必然剩余一组<span
class="math inline">\(p_i=i\)</span>，构成矛盾。</p>
<h2 id="d.-atarcher"><a
href="https://atcoder.jp/contests/arc131/tasks/arc131_d">D.
AtArcher</a></h2>
<ol type="1">
<li><p>距离必定<span class="math inline">\(=d\)</span></p></li>
<li><p>中点必定在0附近</p></li>
<li><p>中点最多移动<span
class="math inline">\(O(d)\)</span>，而所有所属区间的变化数量为<span
class="math inline">\(O(m)\)</span></p></li>
<li><p>线性扫描即可</p></li>
</ol>
<h2 id="e.-christmas-wreath"><a
href="https://atcoder.jp/contests/arc131/tasks/arc131_e">E. Christmas
Wreath</a></h2>
<p>思路：先判定有解后构造/优先考虑特殊限制</p>
<h3 id="有解条件">有解条件</h3>
<p><span class="math inline">\(n \not=2(mod\ 3)\)</span></p>
<h3 id="考虑如何满足条件2">考虑如何满足条件2</h3>
<p>    如果每一个点的邻接边都同色，则条件2必然满足。</p>
<p>问题转化为：将<span class="math inline">\(1,2,3\dots
n-1\)</span>分成和相等的三组。</p>
<p>增量构造即可。</p>
]]></content>
      <categories>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>construction</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Regular Contest 132</title>
    <url>/2021/12/29/AtCoder-Regular-Contest-132/</url>
    <content><![CDATA[<h1 id="atcoder-regular-contest-132"><a
href="https://atcoder.jp/contests/arc132">AtCoder Regular Contest
132</a></h1>
<h2 id="d---between-two-binary-strings"><a
href="https://atcoder.jp/contests/arc132/tasks/arc132_d">D - Between Two
Binary Strings</a></h2>
<p>notice the position of <span class="math inline">\(n\)</span>-th '1'
in a valid string should always between that in both <code>s</code> and
<code>t</code>.</p>
<p>Yet this conclusion can be written in a more compact form: <span
class="math inline">\(\forall i, \#s[1,i]=\#t[1,i]\)</span>.</p>
<p>The problem can be solved greedily as long as the restrictions are
meet.</p>
<p>Proof:</p>
<p>Consider a string to be a 2D path, where '0' means go forward and '1'
means go up.</p>
<p>Thus we need to minimize the turns we made.</p>
<p>It's sufficient that we never make a turn unless we collide with the
border.</p>
<p><a
href="https://atcoder.jp/contests/arc132/submissions/28217621">Submission
#28217621 - AtCoder Regular Contest 132</a></p>
<h2 id="e---paw"><a
href="https://atcoder.jp/contests/arc132/tasks/arc132_e">E -
Paw</a></h2>
<p>Key: the resulting string always looks like this:
<code>&lt;&lt;&lt;&lt;&lt;xxxxxxx&gt;&gt;&gt;&gt;&gt;&gt;</code>, where
<code>x</code> stands for the original character.</p>
<p>The key observation yields to a straight-forward <code>DP</code>
solution.</p>
<p><a
href="https://atcoder.jp/contests/arc132/submissions/28219119">Submission
#28219119 - AtCoder Regular Contest 132</a></p>
<h2 id="f---takahashi-the-strongest"><a
href="https://atcoder.jp/contests/arc132/tasks/arc132_f">F - Takahashi
The Strongest</a></h2>
<p>Let's find the probability distribution of all possible
situations.</p>
<p>Let <span
class="math inline">\(\sigma:[0,2]^k\times[0,2]^k\rightarrow
[0,3]^k\)</span> be the mappings from the strategy of 2 players to
situations.</p>
<p>Suppose <span class="math inline">\(s=\sigma(u,v)\)</span>, then</p>
$$ s_i=
<span class="math display">\[\begin{cases}
3,u_i\neq v_i\\

u_i,u_i=v_i
\end{cases}\]</span>
<p>$$</p>
<p>We can calculate the probability distribution by convolution:</p>
<p><span class="math display">\[
Pr_s=\sum_{s=\sigma(u,v)}Aoki_uSnuke_v
\]</span></p>
<p>To implement that, we simply derive a new transform from
<code>FWT</code>, which will work in <span
class="math inline">\(O(k4^k)\)</span> time.</p>
<p>Formally, Let <span
class="math inline">\(F_s=\sum_{s=\sigma&#39;(u)}Aoki_u\)</span>, and
<span
class="math inline">\(G_s=\sum_{s=\sigma&#39;(u)}Snuke_u\)</span>.</p>
<p>Notice in mapping <span class="math inline">\(\sigma&#39;\)</span>,
every <span class="math inline">\(c\in[0,2]\)</span> points to both
<span class="math inline">\(c\)</span> and <span
class="math inline">\(3\)</span>.</p>
<p>Then <span class="math inline">\(Pr_s=F_s \cdot G_s\)</span> yields
naturally.</p>
<p>To calculate the probability of Takahashi winning over all scenarios,
we just need to perform a similar process.</p>
<p><a
href="https://atcoder.jp/contests/arc132/submissions/28266429">Submission
#28266429 - AtCoder Regular Contest 132</a></p>
]]></content>
      <categories>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>construction</tag>
        <tag>greedy</tag>
        <tag>bubble sort</tag>
        <tag>path-2D</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Regular Contest 135</title>
    <url>/2022/02/15/AtCoder-Regular-Contest-135/</url>
    <content><![CDATA[<h1 id="atcoder-regular-contest-135"><a
href="https://atcoder.jp/contests/arc135/tasks">AtCoder Regular Contest
135</a></h1>
<h2 id="d---add-to-square"><a
href="https://atcoder.jp/contests/arc135/tasks/arc135_d">D - Add to
Square</a></h2>
<p>考虑寻找不变式。</p>
<p>发现<span
class="math inline">\(r_i=\sum_{i,j}(-1)^{ij}A_{ij}\)</span>与<span
class="math inline">\(c_j=\sum_{i,j}(-1)^{ij}A_{ij}\)</span>是不变的。充分性可以贪心消元构造。</p>
<p>于是把每个数乘上<span
class="math inline">\((-1)^{ij}\)</span>以后，就变成每行/列和不变。</p>
<p>答案就是行/列的绝对值的和中更大的那个。</p>
<h2 id="e---sequence-of-multiples"><a
href="https://atcoder.jp/contests/arc135/tasks/arc135_e">E - Sequence of
Multiples</a></h2>
<p>不妨设<span class="math inline">\(B_i=A_i/i\)</span>. 有递归式<span
class="math inline">\(B_{i+1}=\lfloor \dfrac
{iB_{i}}{i+1}\rfloor+1\)</span>. 至此通过枚举不同的<span
class="math inline">\(B\)</span>可以做到<span
class="math inline">\(O(\sqrt N)\)</span>. 发现可以继续差分， 令<span
class="math inline">\(C_i=B_i-B_{i+1}\)</span>， 枚举<span
class="math inline">\(C_i\)</span>可以做到<span
class="math inline">\(O(\sqrt[3] N)\)</span>.</p>
<h2 id="f---delete-1-4-7-..."><a
href="https://atcoder.jp/contests/arc135/tasks/arc135_f">F - Delete 1,
4, 7, ...</a></h2>
<p>考虑通过<span
class="math inline">\(f(x)=\lfloor1.5x\rfloor+1\)</span>来表示保留的数原来的位置.</p>
<p>这样就可以用<span
class="math inline">\(f^{(k)}(x)\)</span>通过复合计算出原来留下了哪些数.</p>
<p>考虑当<span class="math inline">\(k\)</span>较大时, 最终剩下的数较少,
可以直接暴力.</p>
<p>当<span class="math inline">\(k\)</span>较小时, 需要考虑研究<span
class="math inline">\(f\)</span>的性质: <span
class="math inline">\(f^{(k)}(x+2^k)=f^{(k)}(x)+3^k\)</span>.</p>
<p>然而<span class="math inline">\(O(k2^k)\)</span>的做法不能通过...,
发现可以重复利用这个性质: <span
class="math inline">\(f^{a+b}(x+2^b)=f^a(f^b(x)+3^b)\)</span></p>
<p>内层是一堆形如<span class="math inline">\(a, a + c, a + 2c
\dots\)</span>的数的点值. 倍增即可.</p>
]]></content>
      <categories>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>construction</tag>
        <tag>invariants</tag>
        <tag>observation</tag>
      </tags>
  </entry>
  <entry>
    <title>Baka&#39;s Trick</title>
    <url>/2022/01/15/Baka-s-Trick/</url>
    <content><![CDATA[<h1 id="双栈法bakas-trick">双栈法/Baka's Trick</h1>
<h2 id="回避删除的尺取法">回避删除的尺取法</h2>
<p>要求可以快速插入,快速合并区间答案. <a
href="https://www.luogu.com.cn/blog/adfgas/fou-dai-shan-di-chi-qu">参考博客</a>
核心是预处理出区间左半边的答案,从而在不涉及删除的情况下实现左指针右移.
<a href="https://codeforces.com/contest/1549/problem/D">CF1549D</a> ##
双栈法</p>
]]></content>
      <tags>
        <tag>useful algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>CCO &#39;21</title>
    <url>/2022/01/28/CCO-21/</url>
    <content><![CDATA[<h2 id="cco-2021换换排序"><a href="https://loj.ac/p/3577">「CCO
2021」换换排序</a></h2>
<p>题意转化为: <span
class="math inline">\(Q\)</span>次查询数组中两个值之间形成的逆序对数.</p>
<p>这个问题可以利用双指针在<span
class="math inline">\(O(\#a+\#b)\)</span>时间内解决, 且贡献是对称的.</p>
<p>考虑根号分治, 对于<span class="math inline">\(\#a\ge B\)</span>的值,
利用<span class="math inline">\(O(n\cdot
\#a)\)</span>时间求出对所有数的逆序对个数.</p>
<p>对于其余部分, 每次询问时间是<span class="math inline">\(O(B)\)</span>
的.</p>
<p>时间可以做到<span class="math inline">\(O(n\sqrt Q)\)</span></p>
<p>空间: 在线<span class="math inline">\(O(n\sqrt n)\)</span>, 离线<span
class="math inline">\(O(n)\)</span>.</p>
<h2 id="cco-2021在黑暗中走出另一个迷宫"><a
href="https://loj.ac/p/3579">「CCO 2021」在黑暗中走出另一个迷宫</a></h2>
<p>考虑如果每一个指针都指向父亲, 移动的过程就是Euler Tour.</p>
<p>考虑到当每个点被第一次访问到以后, 回溯时一定会把指针指向它的父亲.</p>
<p>模拟这个让整棵树逐渐变得"合法"的过程: 每访问一个"不合法"的节点,
对在指针顺时针方向的节点都进行访问(按照dfs序), 然后回溯.
而剩下的节点一定会在下一轮从根出发时被第一次访问到.</p>
<p>于是直接进行dfs, 每次dfs顺时针方向的儿子, 把其他的儿子加入一个队列中,
依次处理, 可以得到每一个点最早访问到的轮数.</p>
<p>于是问题转化为在欧拉序上不断插入, 查询第k大.</p>
<p>时间<span class="math inline">\(O(n\log n + Q)\)</span>.</p>
<h2 id="cco-2021商旅"><a href="https://loj.ac/p/3580">「CCO
2021」商旅</a></h2>
<p>首先对没有出度的点递归删除, 去除无解情况.</p>
<p>现在考虑最大边权的边<span class="math inline">\(e\)</span>,
如果它是<span class="math inline">\(e.u\)</span>的唯一出边, 则<span
class="math inline">\(e.u\)</span>的答案一定是<span
class="math inline">\(e.r\)</span>. 删掉这条边,
并递归删除无出度的点和它连的边. 删除边<span
class="math inline">\(e\)</span>时, <span
class="math inline">\(\mathrm{chkmin}(Ans_{e.u},
\max(e.r,Ans_{e.v}-e.p))\)</span>.</p>
<p>如果它不是唯一出边, 这条边一定不对答案造成影响, 直接删掉.</p>
<p>对于残余图重新进行这个操作即可. 注意唯一出边时用<span
class="math inline">\(\mathrm{chkmin}\)</span>, 不要直接赋值,
因为可能再递归删除时得到了更小的答案.</p>
]]></content>
  </entry>
  <entry>
    <title>Codeforces Global Round 17</title>
    <url>/2021/12/02/Codeforces-Global-Round-17/</url>
    <content><![CDATA[<h1 id="codeforces-global-round-17"><a
href="https://codeforces.com/contest/1610">Codeforces Global Round
17</a></h1>
]]></content>
      <categories>
        <category>CodeForces</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round #738 (Div. 2)</title>
    <url>/2021/08/16/Codeforces-Round-738-Div-2/</url>
    <content><![CDATA[<h2 id="codeforces-round-738-div.-2">Codeforces Round #738 (Div. 2)</h2>
<p>statistics: problem solved: 4/6 realtime, 1 after contest.</p>
<h4 id="c---mocha-and-hiking"><a
href="https://codeforces.com/contest/1559/problem/C"
title="Codeforces Round 738 (Div. 2)">C - Mocha and Hiking</a></h4>
<p>This problem is a partial proof that</p>
<blockquote>
<p>There always exists an Hamiltonian path in a tournament graph.</p>
</blockquote>
<h4 id="d2.-mocha-and-diana-hard-version"><em>D2. Mocha and Diana (Hard
Version)</em></h4>
<p><a href="https://codeforces.com/contest/1559/problem/D2">Problem - D2
- Codeforces</a></p>
<p>Approach: greedy graph matching technique.</p>
<p>First, try add all possible edge <span class="math inline">\((1,
u)\)</span></p>
<p>Then all nodes which are not in the same component as node 1 must be
in the same component with node 1 in the second graph.</p>
<p>Now we will consider nodes of two types, the ones that are in the
same component than 1 in the first tree, and the ones that are in the
same component than 1 in the second tree. We will store all nodes of
type 1 in a stack p1, and all nodes of type 2 in a stack p2, and we will
try to match them with the following algorithm.</p>
<ul>
<li><p>If the top of p1 is in the same component than 1 in both trees,
delete it</p></li>
<li><p>If the top of p2 is in the same component than 1 in both trees,
delete it</p></li>
<li><p>Otherwise, add an edge between the top of p1 and the top
of p2.</p></li>
</ul>
<h4 id="e.-mocha-and-stars">E. Mocha and Stars</h4>
<p><a href="https://codeforces.com/contest/1559/problem/E">Problem - E -
Codeforces</a></p>
<p>Approach: Mobius Inversion (the good old gcd inversion)</p>
<p><span class="math display">\[
\begin{aligned}
Ans=&amp; \sum_{l_i \le a_i \le r_i}[\sum a_i \le m][gcd(a_i) = 1]\\
=&amp; \sum_d \mu(d)\sum_{l_i \le a_i \le r_i}[\sum a_i \le m][a_i|d]\\
=&amp; \sum_d \mu(d) \sum_{\lceil\frac{l_i}{d} \rceil \le a_i \le
\lfloor \frac{r_i}{d}\rfloor}[\sum a_i \le \lfloor\frac{m}{d}\rfloor]\\
\end{aligned}
\]</span></p>
<p>the rest part is just some <span
class="math inline">\([z^k]\frac{1}{(1 - z)^{n +
1}}\prod(1-z^{k_i})\)</span>, which can be solved <span
class="math inline">\(O(nk)\)</span> through DP</p>
<p>Total time complexity:<span class="math inline">\(O(nm\ln
m)\)</span></p>
]]></content>
      <categories>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>GCD inversion</tag>
        <tag>graph matching</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #747 (Div. 2)</title>
    <url>/2021/10/09/Codeforces-Round-747-Div-2/</url>
    <content><![CDATA[<h1 id="codeforces-round-747-div.-2"><a
href="https://codeforces.com/contest/1594">Codeforces Round #747 (Div.
2)</a></h1>
<h3 id="f---ideal-farm"><a
href="https://codeforces.com/contest/1594/problem/F">F - Ideal
Farm</a></h3>
<p>let <span class="math inline">\(s_i=\sum_{k\le i}a_i\)</span></p>
<p>The Farm is ideal only if there exist <span
class="math inline">\(s_i=s_j+k\)</span>.</p>
<p>let <span class="math inline">\(t_i=s_i+k\)</span>, <span
class="math inline">\(t_0=k\)</span></p>
<p>The Farm is ideal only if for all possible <span
class="math inline">\(\{a_n\}\)</span>, a <span
class="math inline">\(s_i\)</span> coincides with <span
class="math inline">\(t_j\)</span>.</p>
<p>Since <span class="math inline">\(s_i,t_i \in[1, s + k]\)</span>, we
can calculate the maximum possible <span
class="math inline">\(n\)</span>.</p>
]]></content>
      <categories>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>Pigeonhole principle</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #757 (Div. 2)</title>
    <url>/2021/12/01/Codeforces-Round-757-Div-2/</url>
    <content><![CDATA[<h1 id="codeforces-round-757-div.-2"><a
href="https://codeforces.com/contest/1614">Codeforces Round #757 (Div.
2)</a></h1>
<h2 id="d2---divan-and-kostomuksha"><a
href="https://codeforces.com/contest/1614/problem/D1">D2 - Divan and
Kostomuksha</a></h2>
<p>设计一维状态记录<span
class="math inline">\(\gcd\)</span>即可。不整除的数将自动排在后面。</p>
<p><span class="math display">\[
dp_n=\max_{p\ is\ prime} \{dp_{pn} +\#[a_i|n]-\#[a_i|pn]\}
\]</span></p>
<p>time: <span class="math inline">\(O(n\log\log n)\)</span></p>
<h2 id="e---divan-and-a-cottage"><a
href="https://codeforces.com/contest/1614/problem/E">E - Divan and a
Cottage</a></h2>
<p>线段树动态开点维护函数值。</p>
<p>因为题目中函数单增，故可以使用定位区间的方式确定要修改的区间。</p>
<p>time: <span class="math inline">\(O(n\log n)\)</span></p>
<p>space: <span class="math inline">\(O(n\log n)\)</span></p>
<p><a
href="https://codeforces.com/contest/1614/submission/137577347">submission</a></p>
]]></content>
      <categories>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>number theory</tag>
        <tag>DP: state design</tag>
        <tag>segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #768</title>
    <url>/2022/01/28/Codeforces-Round-768/</url>
    <content><![CDATA[<h1 id="codeforces-round-768"><a
href="https://codeforces.com/contest/1630">Codeforces Round
#768</a></h1>
<h2 id="a.-and-matching"><a
href="https://codeforces.com/contest/1630/problem/A">A. And
Matching</a></h2>
<p>样例已知<span class="math inline">\(n=4,k=3\)</span>无解.</p>
<p>首先直接配对就可以得到<span
class="math inline">\(k=0\)</span>的解.</p>
<p>注意到<span class="math inline">\(k&lt;n\)</span>如果<span
class="math inline">\(k\neq n-1\)</span>, 直接将<span
class="math inline">\(k\)</span>和<span
class="math inline">\(n-1\)</span>配对, <span
class="math inline">\(0\)</span> 和<span
class="math inline">\(n-k-1\)</span>配对即可.</p>
<p>当<span class="math inline">\(k=n-1\)</span>时, <span
class="math inline">\((n-1,n-2)\ (1,3)\ (2,n-4)\
(0,n-3)\)</span>可以解决问题.</p>
<h2 id="d.-flipping-range"><a
href="https://codeforces.com/contest/1630/problem/D">D. Flipping
Range</a></h2>
<p>因为<span class="math inline">\(b_i\le n/2\)</span>,
通过叠加可以实现辗转相减. 于是考虑<span
class="math inline">\(b=\gcd(B)\)</span>即可.</p>
<p>当<span class="math inline">\(b\ge2\)</span>时, 操作是不满秩的,
考虑非自由元部分, 每一个操作在消元后, 只会在前<span
class="math inline">\([0,b-2]\)</span>个位置里留下1个1, 或者全为1.
直接计算消除每一位上的1需要花费的最小价值.</p>
<p>计算答案时对全取正需要的操作消元后, 枚举是否全部异或上1,
根据非自由元的满足情况舍弃这些位置上的最小值即可.</p>
<h2 id="e.-expected-components"><a
href="https://codeforces.com/contest/1630/problem/E">E. Expected
Components</a></h2>
<p>利用Burnside引理分别计算component总数, 和本质不同的排列总数.</p>
<p>其中环上component等于相邻不同色的下标个数.</p>
<p>于是可以对每一个颜色二元组计算贡献.</p>
]]></content>
      <categories>
        <category>CodeForces</category>
      </categories>
  </entry>
  <entry>
    <title>DP practice</title>
    <url>/2021/08/20/DP-practice/</url>
    <content><![CDATA[<h2 id="dp-practices">DP practices</h2>
<h3 id="probabilityexpectations-dp">Probability/Expectations DP</h3>
<h6 id="pkuwc2018随机算法"><a
href="https://loj.ac/p/2540">「PKUWC2018」随机算法</a></h6>
<p>Key Inspection: After deleting a arbitrary node and all its adjacent
nodes from the greatest independent set, the rest is still the greatest
independent set of the remaining parts.</p>
<p>Approach: bitmask-dp, graph-theory</p>
<p><a
href="https://github.com/misaka18931/misaka-cp/blob/9813e62255987cc6bfca12f051f63580b6626b92/loj/p2540.cpp">misaka-cp/p2540.cpp</a></p>
<h3 id="dp-over-digits">DP over digits</h3>
<p><a href="https://www.luogu.com.cn/problem/P4127">[AHOI2009]同类分布 -
洛谷</a> <a
href="https://github.com/misaka18931/misaka-cp/blob/9c8a11ba66983acbc8843c33a09c2b6d1357357c/luogu/P4127.cpp">code</a></p>
<h3 id="contribution-split">contribution split</h3>
<p><a href="https://codeforces.com/problemset/problem/1238/E">Problem -
1238E - Codeforces</a> <a
href="https://github.com/misaka18931/misaka-cp/blob/9c8a11ba66983acbc8843c33a09c2b6d1357357c/codeforces/1238E.cpp">code</a></p>
<h3 id="data-structure">data structure</h3>
<p><a href="https://atcoder.jp/contests/dp/tasks/dp_w">W - Intervals</a>
<a
href="https://github.com/misaka18931/misaka-cp/blob/9c8a11ba66983acbc8843c33a09c2b6d1357357c/atcoder/dp_w.cpp">code</a></p>
<h3 id="counting">counting</h3>
<p><a href="https://atcoder.jp/contests/dp/tasks/dp_y">Y - Grid 2</a> <a
href="https://github.com/misaka18931/misaka-cp/blob/9c8a11ba66983acbc8843c33a09c2b6d1357357c/atcoder/dp_y.cpp">code</a></p>
]]></content>
      <categories>
        <category>practice archive</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DS on trees</title>
    <url>/2021/08/24/DS-on-trees/</url>
    <content><![CDATA[<h2 id="data-structuredivide-and-conquer-technique-on-trees">Data
structure/Divide and Conquer Technique On Trees</h2>
<h3 id="centroid-decomposition点分治">Centroid
Decomposition（点分治）</h3>
<p><a href="https://www.luogu.com.cn/problem/P4149">[IOI2011]Race -
洛谷</a></p>
<h3 id="dsu-on-tree">DSU on Tree</h3>
<p><a href="https://codeforces.com/contest/741/problem/D">Problem - D -
Codeforces</a></p>
<h3 id="centroid-tree点分树动态点分治">Centroid
Tree（点分树/动态点分治）</h3>
<h4 id="the-essence-of-centroid-decomposition">The essence of Centroid
Decomposition:</h4>
<p><a
href="https://tanujkhattar.wordpress.com/2016/01/10/centroid-decomposition-of-a-tree/">Tanuj
Khattar's Tutorial on Centroid Tree</a></p>
<blockquote>
<p><strong>Consider any two arbitrary vertices A and B and the path
between them (in the original tree) can be broken down into A–&gt;C and
C–&gt;B where C is LCA of A and B in the centroid tree.</strong></p>
</blockquote>
<blockquote>
<p>The vertex C can also be seen as : If we assign labels to centroids
in the order in which they are removed from the graph / labels equal to
the level at which the centroid occurs in the centroid tree, then C
would be the node with smallest label on the path from A–&gt;B in the
original tree</p>
</blockquote>
<p>Therefore centroid tree breakdown every <span
class="math inline">\(O(n^2)\)</span> path by centroids in a certain
layer. When we try to extract all paths passing by an arbitrary node
<span class="math inline">\(u\)</span>, all relevant centroids are
ancestors of <span class="math inline">\(u\)</span> on centroid
tree.</p>
<p>Additionally, non simple paths(which fall back to the same sub-tree
as <span class="math inline">\(u\)</span> on centroid tree) needs to be
excluded.</p>
<h4 id="exercises">Exercises:</h4>
<p><a href="https://codeforces.com/contest/757/problem/G">Problem - G -
Codeforces</a> CF757G centroid tree + dynamic segment tree /
<strong>Persistent Centroid Tree</strong></p>
<p><a href="https://www.luogu.com.cn/problem/P6329">【模板】点分树 |
震波 - 洛谷</a></p>
<h3 id="heavy-light-decomposition-链分治">Heavy-Light Decomposition
（链分治）</h3>
<h4 id="tricks">Tricks</h4>
<p><strong>链加，单点查询<span
class="math inline">\(\rightarrow\)</span> 树上差分BIT</strong></p>
<h4 id="exercises-1">Exercises:</h4>
<p><a href="https://www.luogu.com.cn/problem/P4216">[SCOI2015]情报传递 -
洛谷</a>
利用树上差分，维护一个点到根的和，单点修改时只用修改受影响的子树。</p>
<p><a href="https://www.luogu.com.cn/problem/P4211">[LNOI2014]LCA -
洛谷</a> 对于区间可减贡献，可以将<span class="math inline">\([l, r]
\rightarrow[0, r] - [0, l - 1]\)</span> 扫描线完成</p>
<p><a href="https://www.luogu.com.cn/problem/P4219">[BJOI2014]大融合 -
洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P5354">[Ynoi2017] 由乃的 OJ
- 洛谷</a> directed path, double constant. Difficulty: lxl</p>
<p><a href="https://darkbzoj.tk/problem/4771">七彩树 - 题目 -
黑暗爆炸OJ</a></p>
]]></content>
      <tags>
        <tag>data structure</tag>
        <tag>HLD</tag>
        <tag>Centroid Decomposition</tag>
        <tag>DSU on tree</tag>
        <tag>Centroid Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Deltix Round, Summer 2021 (Div.1 + Div.2)</title>
    <url>/2021/08/31/Deltix-Round-Summer-2021-Div-1-Div-2/</url>
    <content><![CDATA[<h2 id="deltix-round-summer-2021-div.1-div.2">Deltix Round, Summer 2021
(Div.1 + Div.2)</h2>
<h3 id="problem---d---codeforces"><a
href="https://codeforces.com/contest/1556/problem/D">Problem - D -
Codeforces</a></h3>
<p>key inspection:</p>
<p><span class="math display">\[
a\ \mathrm{and}\ b + a\ \mathrm{\text or}\ b = a + b
\]</span></p>
]]></content>
      <categories>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>bitmask</tag>
        <tag>subset DP (graph)</tag>
      </tags>
  </entry>
  <entry>
    <title>Deltix Round, Autumn 2021 (Div. 1 + Div. 2)</title>
    <url>/2021/12/01/Deltix-Round-Autumn-2021-open-for-everyone-rated-Div-1-Div-2/</url>
    <content><![CDATA[<h1
id="deltix-round-autumn-2021-open-for-everyone-rated-div.-1-div.-2"><a
href="https://codeforces.com/contest/1609">Deltix Round, Autumn 2021
(open for everyone, rated, Div. 1 + Div. 2)</a></h1>
<h2 id="e.-william-the-oblivious"><a
href="https://codeforces.com/contest/1609/problem/E">E. William The
Oblivious</a></h2>
<h3 id="solution-1-dynamic-divide-and-conquer-segment-tree">solution 1:
(dynamic divide and conquer / segment tree)</h3>
<p><span class="math display">\[
\begin{aligned}
Ans =&amp; \min_{l\le r}\{S[0,l)\#a+S[l,r)\#b+S[r,n)\#c\}  \\
=&amp; \ S\#b+\min_{l\le r}\{S[0,l)\#(a-b)+S[r,n)\#(c-b)\}
\end{aligned}
\]</span></p>
<p>线段树维护区间最小前缀、后缀、答案即可。</p>
<h3 id="solution-2-ddp">solution 2: (DDP)</h3>
<p>WIP</p>
<p><a
href="https://codeforces.com/contest/1609/submission/137581443">submission</a></p>
<h2 id="f.-interesting-sections"><a
href="https://codeforces.com/contest/1609/problem/F">F. Interesting
Sections</a></h2>
<p><span class="math display">\[
Ans=\sum_{l\le r}[\mathrm{popcnt}(\min\{a_l\dots a_r\}) =
\mathrm{popcnt}(\max\\a_l\dots a_r\})]
\]</span></p>
<p>应用单调栈+线段树维护最大值个数。</p>
<p>time: <span class="math inline">\(O(n\log \max a+n\log
n)\)</span></p>
<p>space: <span class="math inline">\(O(n)\)</span></p>
<p><a
href="https://codeforces.com/contest/1609/submission/137318184">submission</a></p>
<h2 id="g.-a-stroll-around-the-matrix"><a
href="https://codeforces.com/contest/1609/problem/G">G. A Stroll Around
the Matrix</a></h2>
<p>思路：先考虑静态问题，构造最优解/通过作差（微调法）将高维问题降维处理。</p>
]]></content>
      <categories>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>segment tree</tag>
        <tag>dynamic divide and conquer</tag>
        <tag>dynamic DP</tag>
        <tag>monotonic stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 118</title>
    <url>/2021/12/03/Educational-Codeforces-Round-118/</url>
    <content><![CDATA[<h1 id="educational-codeforces-round-118"><a
href="https://codeforces.com/contest/1613">Educational Codeforces Round
118</a></h1>
<h2 id="d.-mex-sequences"><a
href="https://codeforces.com/contest/1613/problem/D">D. MEX
Sequences</a></h2>
<p>A subsequence is valid if and only if one of the following is true
for any prefix.</p>
<ol type="1">
<li><p><span class="math inline">\(\{b_1, b_2\dots b_k\}=[0,k]\)</span>.
(expandable)</p></li>
<li><p><span class="math inline">\(\{b_1, b_2\dots
b_k\}=[0,k]\cup\{k+2\}\)</span>. (non-expandable)</p></li>
</ol>
<p>We can maintain the number of type 1/ type 2 subsequences with <span
class="math inline">\(\mathrm MEX = k\)</span>, while adding <span
class="math inline">\(a_i\)</span> accordingly.</p>
<p><a
href="https://codeforces.com/contest/1613/submission/137670831">submission:
137670831</a></p>
<h2 id="e.-crazy-robot"><a
href="https://codeforces.com/contest/1613/problem/E">E. Crazy
Robot</a></h2>
<p>elementary BFS practice.</p>
<p><a
href="https://codeforces.com/contest/1613/submission/137695116">submission:
137695116</a></p>
<h2 id="f.-tree-coloring"><a
href="https://codeforces.com/contest/1613/problem/F">F. Tree
Coloring</a></h2>
<p>The objective is hard to achieve directly. We can apply
Inclusion-Exclusion Principle to simplify the constrains.</p>
<p>Let <span class="math inline">\(f(n)\)</span> be the number of
coloring that has <strong>at least</strong> <span
class="math inline">\(n\)</span> edges with <span
class="math inline">\(c_{fa} =c_v +1\)</span>.</p>
<p>Then <span class="math inline">\(Ans=\sum_{k}(-1)^kf(k)\)</span>.</p>
<p><span class="math inline">\(f(n)\)</span> can be calculated using
divide-and-conquer FFT from the equation below.</p>
<p><span class="math display">\[
f(k)=(n-k)!\sum_{u_1,u_2\dots u_k\in V}\prod_{i=1}^k|childs(u_i)|
\]</span></p>
<p>time: <span class="math inline">\(O(n\log^2n)\)</span></p>
<p>space: <span class="math inline">\(O(n)\)</span></p>
<p><a
href="https://codeforces.com/contest/1613/submission/137813335">submission:
137813335</a></p>
]]></content>
      <categories>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>Inclusion-Exclusion Principle</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 119</title>
    <url>/2021/12/21/Educational-Codeforces-Round-119/</url>
    <content><![CDATA[<h1 id="educational-codeforces-round-119"><a
href="https://codeforces.com/contest/1620">Educational Codeforces Round
119</a></h1>
<h2 id="f.-bipartite-array"><a
href="https://codeforces.com/contest/1620/problem/F">F. Bipartite
Array</a></h2>
<p>容易发现，二分序列一定可以划分成小于2个上升子序列。</p>
<p>由Dilworth定理，条件等价为<span
class="math inline">\(LDS\le2\)</span>。</p>
<p>考虑dp， 记录<span class="math inline">\(l=1\)</span>和<span
class="math inline">\(l=2\)</span>的下降子序列中的最小的数。</p>
<p>得到<span class="math inline">\(O(n^3)\)</span>做法。</p>
<p>WIP...</p>
]]></content>
      <categories>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>Dilworth&#39;s theorem</tag>
      </tags>
  </entry>
  <entry>
    <title>GF for counting</title>
    <url>/2021/09/28/GF-for-counting/</url>
    <content><![CDATA[<h1 id="dependencies">Dependencies</h1>
<p><span class="math display">\[
\log(1+z)=\sum_{k\ge1}\frac1k(-1)^{k-1}z^k
\]</span></p>
<p><span class="math display">\[
\exp(z)=\sum_{k\ge0}\frac{z^k}{k!}
\]</span></p>
<h3 id="lagrange-inversion">Lagrange Inversion</h3>
<p>given polynomial <span class="math inline">\(h\)</span> where <span
class="math inline">\(h_0=0\)</span> and <span
class="math inline">\(h_1\not=0\)</span>, find <span
class="math inline">\(y\)</span> which <span
class="math inline">\(z=h(y(z))\)</span> holds.</p>
<p>Let <span class="math inline">\(\phi(y)=y/h(y)\)</span>.</p>
<p>Formally, When</p>
<p><span class="math display">\[
y(z)=z\,\phi(y)
\]</span></p>
<p>We have</p>
<p><span class="math display">\[
y_n=\frac1n[u^{n-1}]\phi(u)^{n}
\]</span></p>
<p><span class="math display">\[
[z^n]y(z)^k=\frac k n[u^{n-k}]\phi(u)^n
\]</span></p>
<p><span class="math display">\[
[z^n]H(y(z))=\frac1n[u^n](H^{&#39;}(u)\ \phi(u)^n)
\]</span></p>
<p>Tip: When The Tree equations are too intense to solve try Lagrange
Inversion!</p>
<h1 id="ogf">OGF</h1>
<h3 id="basic-constructions">Basic Constructions</h3>
<p><span class="math inline">\(B=SEQ(A)\)</span></p>
<p><span class="math display">\[
B(z)=\frac{1}{1-A(z)}
\]</span></p>
<p><span class="math inline">\(B=PSET(A)\)</span></p>
<p><span class="math display">\[
B(z)=\exp(\sum_{k\ge1}\frac{(-1)^{k-1}}{k}A(z^k))
\]</span></p>
<p><span class="math inline">\(B=MSET(A)\)</span></p>
<p><span class="math display">\[
B(z)=\exp(\sum_{k\ge1}\frac{1}{k}A(z^k))
\]</span></p>
<p><span class="math inline">\(B=CYC(A)\)</span></p>
<p><span class="math display">\[
B(z)=\sum_{k\ge1}\frac{\varphi(k)}{k}\log(\frac{1}{1-A(z^k)})
\]</span></p>
<h5 id="note">Note:</h5>
<p>Those equations handle the empty object implicitly, thus:</p>
<ul>
<li><p>For general constructions, <span
class="math inline">\(A_0=0\)</span> holds.</p></li>
<li><p>For size-restricted constructions <span
class="math inline">\(A_0=1\)</span> holds.</p></li>
</ul>
<h3 id="polya-theorem">Polya Theorem</h3>
<p>Cycle Index</p>
<p><span class="math display">\[
Z(G;x_1,x_2, \dots, x_m)=\frac1{|G|}\sum_{g\in
G}x_1^{j_1(g)}x_2^{j_2(g)}\cdots x_m^{j_m(g)}
\]</span></p>
<p>OGF over Groups</p>
<p><span class="math inline">\(B=A^M/G\)</span></p>
<p><span class="math display">\[
B(z)=Z(G;A(z),A(z^2),\dots,A(z^m))
\]</span></p>
<p>Memorize</p>
<ul>
<li><p>Cycle <span class="math inline">\(Z=\frac1
m\sum_{d|m}\varphi(d)x_d^{n/d}\)</span></p></li>
<li><p>Mirror <span class="math inline">\(Z=\frac1
2x_1^{2v}+\frac12x_2^v\)</span> or <span
class="math inline">\(Z=\frac12x_1^{2v+1}+\frac12x_1x_2^v\)</span></p></li>
<li><p>All Permutations <span
class="math inline">\(Z=\sum(z^{j_1}z^{j_2}\cdots
z^{j_m})/(j_1!j_2!\cdots j_m!1^{j_1}2^{j_2}\cdots
m^{j_m})\)</span></p></li>
</ul>
<h3 id="pset_kmset_k的计算"><span
class="math inline">\(PSET_k,MSET_k\)</span>的计算</h3>
<p>需要枚举拆分数，套用cycle index</p>
<p>注意，PSET构造时对<span
class="math inline">\(F(z)\)</span>符号取负即可</p>
<h3 id="additional-useless-formula">Additional Useless formula</h3>
<p><span class="math display">\[
MSET_k(F) = [u^k]\exp(\sum_{k\ge1}\frac{u^k}kF(z^k))
\]</span></p>
<p><span class="math display">\[
PSET_k(F) = [u^k]\exp(\sum_{k\ge1}\frac{u^k}k(-1)^{k-1}F(z^k))
\]</span></p>
<p><span class="math display">\[
CYC_k(F)=[u^k]\sum_{k\ge1}\frac{\varphi(k)}k\log(\frac1{1-u^kF(z^k)})
\]</span></p>
<h1 id="egf">EGF</h1>
<p><span class="math inline">\(B=SEQ(A)\)</span></p>
<p><span class="math display">\[
B(z)=\frac1{1-A(z)}
\]</span></p>
<p><span class="math inline">\(B=SET(A)\)</span></p>
<p><span class="math display">\[
B(z)=\exp(A(z))
\]</span></p>
<p>*objects are distinguishable through labels anyway.</p>
<p><span class="math inline">\(B=CYC(A)\)</span></p>
<p><span class="math display">\[
B(z)=\log(\frac1{1-A(z)})
\]</span></p>
<p>*same here.</p>
<p><span class="math inline">\(B=SET_k(A)\)</span></p>
<p><span class="math display">\[
B(z)=\frac1{k!}A(z)^k
\]</span></p>
<h3 id="additional-constructions">Additional constructions</h3>
<p><span class="math inline">\(graph\,F\rightarrow connected\
graph\,G\)</span> (applying inverse operation of exp/polya exp)</p>
<p><span class="math inline">\(MSET(G)=F\)</span></p>
<p><span class="math display">\[
G(z)=\log(F(z))
\]</span></p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>OGF</tag>
        <tag>Polya Counting</tag>
      </tags>
  </entry>
  <entry>
    <title>Generating Functions and Combinatorics Classes</title>
    <url>/2021/09/29/Generating-Functions-and-Combinatorics-Classes/</url>
    <content><![CDATA[<h1 id="generating-functions-and-combinatorics-classes">Generating
Functions and Combinatorics Classes</h1>
]]></content>
      <tags>
        <tag>OGF</tag>
        <tag>EGF</tag>
        <tag>counting</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello 2022</title>
    <url>/2022/01/01/Hello-2022/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>JOI 2022 Final</title>
    <url>/2022/02/16/JOI-2022-Final/</url>
    <content><![CDATA[<h1 id="joi-2022-final">JOI 2022 Final</h1>
<h2 id="joi-2022-final星际蛋糕推销"><a
href="https://loj.ac/p/3662">#3662. 「JOI 2022
Final」星际蛋糕推销</a></h2>
<p><del>implement useful algorithm</del></p>
<h2 id="joi-2022-final自学"><a href="https://loj.ac/p/3663">#3663. 「JOI
2022 Final」自学</a></h2>
<p>useful algorithm<span class="math inline">\(\times2\)</span>.</p>
<h2 id="joi-2022-final选举"><a href="https://loj.ac/p/3664">#3664. 「JOI
2022 Final」选举</a></h2>
<p>直接枚举最终一共有<span
class="math inline">\(m\)</span>人在演讲.考虑当确定哪些city需要招人,
另外哪些要拿到选票时, 一定是先把人招全, 再拿到剩下的选票更优.
并且招人的顺序一定是按<span class="math inline">\(b_i\)</span>不减.</p>
<p>于是按照<span class="math inline">\(b_i\)</span>排序,
发现<strong>去掉只拿选票的城市以后,
招到人的城市一定在剩余城市中构成一个前缀</strong>.</p>
<p>定义<span class="math inline">\(f[n][k]\)</span>表示前<span
class="math inline">\(n\)</span>个城市, <span
class="math inline">\(k\)</span>个只拿选票的最短时间. <span
class="math inline">\(O(n^2k)\)</span> DP.</p>
<p>另外据说可以三分<span class="math inline">\(m\)</span>, 正确性不明.
<a
href="https://codeforces.com/blog/entry/99837?#comment-886479">link</a></p>
<h2 id="joi-2022-final铁路旅行-2"><a href="https://loj.ac/p/3665">#3665.
「JOI 2022 Final」铁路旅行 2</a></h2>
<p>经典的倍增+维护可达区间. 这次转移需要用<code>RMQ</code>. <span
class="math inline">\(O(n\log^2 n + q \log n)\)</span>, 空间2log 或
<span class="math inline">\(O((n+q)\log^2 n)\)</span>, 空间1log.</p>
<h2 id="joi-2022-final沙堡-2"><a href="https://loj.ac/p/3666">#3666.
「JOI 2022 Final」沙堡 2</a></h2>
<p>idea: 1. 对于合法状态的判定,
尝试把它写成一个对每一个元素相对独立的函数(即每个元素的贡献具有局部性),
方便后续各种操作. 2. 扫描线</p>
<p>考虑到对于每个数, 我们显然会走它在相邻格子中的前驱和后继,
考虑连一条有向边, 这样一个矩形合法, 也就是成链, 当且仅当<span
class="math inline">\(0\)</span>入度点只有<span
class="math inline">\(1\)</span>个.</p>
<p>而每个点的入度只在border在它附近的时候会变化.</p>
<p>大力前缀和即可.</p>
<p>做到<span class="math inline">\(O(H^2W)\)</span>需要枚举一维,
用一个桶计数另一维.</p>
]]></content>
      <tags>
        <tag>greedy</tag>
        <tag>DP: state design</tag>
        <tag>Inclusion-Exclusion Principle</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ targeted training: DP &amp; Probability &amp; Expectation</title>
    <url>/2022/02/17/LOJ-tags-DP-Probability-Expectation/</url>
    <content><![CDATA[<h1 id="loj定向练习dp-probability-expectation">LOJ定向练习(DP &amp;
Probability &amp; Expectation)</h1>
<h2 id="hnoi2015亚瑟王">#2112. 「HNOI2015」亚瑟王</h2>
<p>如果直接对这个游戏过程DP, 是非常困难的,
我们可以直接考虑终局时选择到每一张牌的概率.</p>
<p>需要考虑两种情况: 1. 某一回合选的牌在他之前(不考虑他). 直接放到状态里
2. 这张牌在前面和回合中已经用过了. 补集转化即可.</p>
<h2 id="zjoi2015地震后的幻想乡">#2136. 「ZJOI2015」地震后的幻想乡</h2>
<p>利用第k大数的期望公式(题目中给出), 枚举MST中瓶颈的大小, 乘上概率即可.
容易求出MST<span class="math inline">\(\le k\)</span>的概率(子集DP),
考虑差分转化.</p>
<h2 id="zjoi2020传统艺能">#3312. 「ZJOI2020」传统艺能</h2>
<p>考虑分别考虑每一个线段树上节点有标记的概率.
利用线段树上定位区间的性质, 利用人类智慧+矩阵快速幂过题.</p>
<h2 id="雅礼集训-2018-day1树">#6495. 「雅礼集训 2018 Day1」树</h2>
<p>数据范围诈骗! 直接递推!</p>
<h2 id="icpc-world-finals-2018绿宝石之岛">#6406. 「ICPC World Finals
2018」绿宝石之岛</h2>
<p>行列转置, 降低复杂度.</p>
<h2 id="pkuwc2018随机游走">#2542. 「PKUWC2018」随机游走</h2>
<p>关于树上随机游走问题:</p>
<p>法一: 计算边权.
期望距离依然具有可加性(考虑按照第一次经过中间点的时间划分)
于是可以使用up and down trick算出每条有向边的期望长度.
这样可求任意路径的长度.</p>
<p>法二: 树形消元解方程 考虑从终点出发倒着进行,
这样就可以列方程解出到每个点的期望. 树形消元的trick: 把起点当成根,
把儿子设成父亲的线性函数, 这样就可以dfs求出每个点的系数, 由于根没有父亲,
根的常数项就是答案.</p>
<h2 id="shoi2017分手是祝愿">#2145. 「SHOI2017」分手是祝愿</h2>
<p>利用算术基本定理, 把因数关系看成高维前缀和,
剩下的部分就是一个一维的随机游走, 差分法解方程即可.</p>
<h2 id="zjoi2019线段树">#3043. 「ZJOI2019」线段树</h2>
<p>把操作1看成: 以<span
class="math inline">\(\frac12\)</span>的概率决定是否进行操作, 就可以利用
#3312 的方法做了.</p>
<h2 id="雅礼集训-2018-day7c">#6509. 「雅礼集训 2018 Day7」C</h2>
<p><strong>TODO</strong> 解方程!</p>
<h2 id="山东二轮集训-day7鬼牌">#6118. 「2017 山东二轮集训
Day7」鬼牌</h2>
<p>推式子练习.</p>
]]></content>
  </entry>
  <entry>
    <title>LibreOJ #575</title>
    <url>/2021/12/30/LibreOJ-575/</url>
    <content><![CDATA[<h1 id="libreoj-noi-round-2不等关系"><a
href="https://loj.ac/p/575">「LibreOJ NOI Round #2」不等关系</a></h1>
<p>题目描述：</p>
<p>给定一个字符串，仅包含 <code>&lt;</code> 和 <code>&gt;</code>
两种字符。你需要计算「使得<span
class="math inline">\(p_i&lt;p_{i+1}\)</span><strong>当且仅当</strong>
<span class="math inline">\(s_i\)</span>为 <code>&lt;</code> 的排列
<span class="math inline">\(p_1,p_2,\dots p_n\)</span> 」的数量。</p>
<p>考虑容斥：<code>&lt;</code>不满足即为<code>&gt;</code>满足，故原问题转化为求满足多个连续段递增的排列数目。</p>
<p>利用<code>FFT</code>优化<code>DP</code>连续段即可。</p>
<p><span class="math display">\[
\begin{aligned}
f_0=&amp;1 \\
f_n=&amp;\sum_{k&lt;n}\mathrm{islt}(s_{k})(-1)^{cnt(n)-cnt({k+1})}
{n\choose k} f_k
\end{aligned}
\]</span></p>
]]></content>
      <tags>
        <tag>FFT</tag>
        <tag>Inclusion-Exclusion Principle</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear Basis</title>
    <url>/2022/01/22/Linear-Basis/</url>
    <content><![CDATA[<h1 id="线性基">线性基</h1>
<h2 id="构造方法">构造方法</h2>
<ul>
<li>逆序枚举 $ t $ 所有为 $ 1 $ 的二进制位 $ j = L $，对于每个 $ j $
<ul>
<li>如果 $ a_j $，则令 $ t = t a_j $</li>
<li>如果 $ a_j = 0 $，则
<ul>
<li>枚举 $ k [0, j) $，如果 $ t $ 的第 $ k $ 位为 $ 1 $，则令 $ t = t
a_k $</li>
<li><strong>枚举 $ k (j, L] $，如果 $ a_k $ 的第 $ j $ 位为 $ 1 $，则令
$ a_k = a_k t $</strong></li>
<li>令 $ a_j = t $，结束插入过程</li>
</ul></li>
</ul></li>
</ul>
<p>*注意: 加粗的步骤保证了特殊性质.</p>
<h2 id="特殊性质">特殊性质</h2>
<p>如上构造的线性基具有很优秀的性质:</p>
<p>每一行要么是空行, 要么<code>a[k]==1</code>并且只有<span
class="math inline">\(i\gt k\)</span> 并且不在线性基中的位<span
class="math inline">\(i\)</span>才有可能为<code>1</code>.
于是看一个数是否属于线性空间, 只需要异或上
<strong>存在于线性基中的元素</strong>
,看其他位置是否全<code>0</code>.</p>
<h2 id="题目">题目</h2>
<p><a href="https://codeforces.com/gym/102082/problem/I">2018-2019,
ICPC, Asia Yokohama Regional Contest 2018 Problem I - Ranks</a></p>
<p>参考文献: <a
href="https://oi.men.ci/linear-basis-notes/">线性基学习笔记 | Menci's
Blog</a></p>
]]></content>
      <tags>
        <tag>linear-basis</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Flow</title>
    <url>/2022/02/23/Network-Flow/</url>
    <content><![CDATA[<h2 id="implementation">Implementation</h2>
<h3 id="dinic最大流">Dinic最大流</h3>
<p>各种剪枝</p>
<h3 id="dinic费用流">Dinic费用流</h3>
<p>队列优化的bellman-ford, 实现时需要注意入队标记!</p>
<h3 id="hlpp最大流">HLPP最大流</h3>
<ol type="1">
<li>用优先队列会多<span class="math inline">\(\log\)</span>. (<span
class="math inline">\(O(n^2\sqrt m\log n)\)</span>)<br />
</li>
<li>直接使用队列是<span class="math inline">\(O(n^3)\)</span>的.</li>
<li>gap优化</li>
<li>bfs确定初始高度.</li>
</ol>
<h2 id="建图">建图</h2>
<h3 id="最大流">最大流</h3>
<p>按照定义建图</p>
<h3 id="最小割">最小割</h3>
<ol type="1">
<li>对于一条路径上的所有边, 是选择关系.</li>
<li>通过连inf边, 实现各种约束条件.</li>
</ol>
<h3 id="二分图匹配">二分图匹配</h3>
<p>在两个集合之间连接有向边即可.</p>
<h3 id="最大权闭合子图">最大权闭合子图</h3>
<p>提前计算所有正权点的贡献.</p>
<p>运用最小割模型, source向正权点连 cap=权值 的边, 表示不选的代价;
负权点向sink连 cap=|权值| 的边, 表示选择的代价.
对原图中的边对应建一条inf边.</p>
<p>发现合法的子图一定是一个割.</p>
<h3 id="最小路径覆盖">最小路径覆盖</h3>
<p>转化为二分图匹配: 每个点入度, 出度最多为1, 并且每连一条边, 入度,
出度均+1. 将每个点拆成入点和出点跑二分图匹配.</p>
<h2 id="网络流24题">网络流24题</h2>
<h3 id="网络流-24-题搭配飞行员">#6000. 「网络流 24 题」搭配飞行员</h3>
<p>二分图最大匹配.</p>
<h3 id="网络流-24-题太空飞行计划">#6001. 「网络流 24
题」太空飞行计划</h3>
<p>转化为最大权闭合子图</p>
<h3 id="网络流-24-题最小路径覆盖">#6002. 「网络流 24
题」最小路径覆盖</h3>
<p>最小路径覆盖</p>
<h3 id="网络流-24-题魔术球">#6003. 「网络流 24 题」魔术球</h3>
<p>增量网络流, 跑最小路径覆盖.</p>
<h3 id="网络流-24-题圆桌聚餐">#6004. 「网络流 24 题」圆桌聚餐</h3>
<p>最大流建图.</p>
<h3 id="网络流-24-题最长递增子序列">#6005. 「网络流 24
题」最长递增子序列</h3>
<p>WA'ed QAQ</p>
<h3 id="网络流-24-题试题库">#6006. 「网络流 24 题」试题库</h3>
<p>最大流建图</p>
<h3 id="网络流-24-题方格取数">#6007. 「网络流 24 题」方格取数</h3>
<p>最小割建图.(多变量选择)</p>
<h3 id="网络流-24-题餐巾计划">#6008. 「网络流 24 题」餐巾计划</h3>
<p>费用流建图</p>
<h3 id="网络流-24-题软件补丁">#6009. 「网络流 24 题」软件补丁</h3>
<p>不是网络流...</p>
<h3 id="网络流-24-题数字梯形">#6010. 「网络流 24 题」数字梯形</h3>
<p>费用流建图</p>
<h3 id="网络流-24-题运输问题">#6011. 「网络流 24 题」运输问题</h3>
<p>费用流建图</p>
<h3 id="网络流-24-题分配问题">#6012. 「网络流 24 题」分配问题</h3>
<p>同 #6011</p>
<h3 id="网络流-24-题负载平衡">#6013. 「网络流 24 题」负载平衡</h3>
<p>简单建图</p>
<h3 id="网络流-24-题最长-k-可重区间集">#6014. 「网络流 24 题」最长 k
可重区间集</h3>
<p>考虑在数轴上建立网络流, 额外加入每一条长度为0的线段,
这样就变成一定覆盖k次.</p>
<h3 id="网络流-24-题星际转移">#6015. 「网络流 24 题」星际转移</h3>
<p>对时间拆点</p>
<h3 id="网络流-24-题孤岛营救问题">#6121. 「网络流 24
题」孤岛营救问题</h3>
<p>直接DP</p>
<h3 id="网络流-24-题航空路线问题">#6122. 「网络流 24
题」航空路线问题</h3>
<p>费用流+拆点.</p>
]]></content>
      <tags>
        <tag>Network Flow</tag>
      </tags>
  </entry>
  <entry>
    <title>Presets for NOI series Algorithm Contests</title>
    <url>/2021/10/23/Presets-for-NOI-series-Algorithm-Contests/</url>
    <content><![CDATA[<h1 id="presets-for-noi-series-algorithm-contests">Presets for NOI
series Algorithm Contests</h1>
<h2 id="system-settings">System Settings</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.interface cursor-blink <span class="literal">false</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.preferences focus-mode mouse</span><br><span class="line">xset r rate 300 50  <span class="comment"># X11 repeat rate</span></span><br></pre></td></tr></table></figure>
<h2 id="editor-configuration">Editor Configuration</h2>
<h3 id="gnome-terminal">GNOME Terminal</h3>
<p>Change color schemes to <code>Tango dark</code>.</p>
<h3 id="vim">Vim</h3>
<p>in <code>~/.vimrc</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line"><span class="keyword">set</span> expandtab softtabstop=<span class="number">2</span> <span class="built_in">shiftwidth</span>=<span class="number">2</span></span><br><span class="line"><span class="keyword">set</span> ai <span class="built_in">cindent</span> copyindent</span><br><span class="line"><span class="keyword">set</span> mouse=<span class="keyword">a</span></span><br><span class="line"><span class="comment">&quot;set number relativenumber</span></span><br><span class="line"><span class="keyword">autocmd</span> BufWritePost *.cpp :!g++ -DMISAKA %:<span class="keyword">p</span> -<span class="keyword">o</span> %:<span class="keyword">p</span>:r</span><br><span class="line"><span class="keyword">autocmd</span> BufNewFile *.cpp <span class="number">0</span>r ~/cpp.cpp</span><br><span class="line"><span class="keyword">nmap</span> S :s//g<span class="symbol">&lt;left&gt;</span><span class="symbol">&lt;left&gt;</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="string">&#x27; &#x27;</span><span class="string">&#x27;&lt;left&gt;</span></span><br><span class="line"><span class="string">inoremap &quot; &quot;&quot;&lt;left&gt;</span></span><br><span class="line"><span class="string">inoremap &#123; &#123;&#125;&lt;left&gt;</span></span><br><span class="line"><span class="string">inoremap ( ()&lt;left&gt;</span></span><br><span class="line"><span class="string">inoremap [ []&lt;left&gt;</span></span><br><span class="line"><span class="string">inoremap &#123; &#123;&#125;&lt;left&gt;</span></span><br><span class="line"><span class="string">inoremap &#123;&lt;CR&gt; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O</span></span><br><span class="line"><span class="string">inoremap &quot;&quot; &quot;</span></span><br><span class="line"><span class="string">inoremap &#x27;</span><span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="keyword">inoremap</span> [[ [</span><br><span class="line"><span class="keyword">inoremap</span> (( (</span><br><span class="line"><span class="keyword">inoremap</span> &#123;&#123; &#123;</span><br></pre></td></tr></table></figure>
<h2 id="codeblocks-ide-configuration-debugging">Code::Blocks IDE
Configuration (Debugging)</h2>
<p><strong>Reminder:</strong> debugging with Code::Blocks requires
pasting original code to <code>main.cpp</code> then paste the modified
version back, be careful!</p>
<ol type="1">
<li><p>Create a new project</p></li>
<li><p>choose Console application</p></li>
<li><p>specify folder name (must done)</p></li>
<li><p>copy code to <code>main.cpp</code> to start debugging;</p></li>
</ol>
<h2 id="code-snippetstemplates">Code Snippets/Templates</h2>
<h3 id="c-main-solution-file">C++ main solution file</h3>
<p>in <code>~/cpp.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> i64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> u64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> u32;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, j, k) for (int i = (j); i &lt; (k); ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROF(i, j, k) for (int i = ((k) - 1); i &gt;= j; --i)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(T &amp;a, <span class="keyword">const</span> T b)</span> </span>&#123;</span><br><span class="line">  a = <span class="built_in">min</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(T &amp;a, <span class="keyword">const</span> T b)</span> </span>&#123;</span><br><span class="line">  a = <span class="built_in">max</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MISAKA</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Checklist:</span></span><br><span class="line"><span class="comment"> * - data type</span></span><br><span class="line"><span class="comment"> * - overflow</span></span><br><span class="line"><span class="comment"> * - typo/logic</span></span><br><span class="line"><span class="comment"> * - special cases</span></span><br><span class="line"><span class="comment"> * - cleanup (multi-test)</span></span><br><span class="line"><span class="comment"> * - bounds</span></span><br><span class="line"><span class="comment"> * - memory usage</span></span><br><span class="line"><span class="comment"> * - file IO</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="c-generator">C++ generator</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> i64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> u64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> u32;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, j, k) for (int i = (j); i &lt; (k); ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROF(i, j, k) for (int i = ((k) - 1); i &gt;= j; --i)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(T &amp;a, <span class="keyword">const</span> T b)</span> </span>&#123;</span><br><span class="line">  a = <span class="built_in">min</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(T &amp;a, <span class="keyword">const</span> T b)</span> </span>&#123;</span><br><span class="line">  a = <span class="built_in">max</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> uniform_int_distribution&lt;<span class="keyword">int</span>&gt; ui;</span><br><span class="line">mt19937 gen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  gen = <span class="built_in">mt19937</span>(chrono::<span class="built_in">steady_clock</span>().<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="checker-script-random-test-cases-batching">checker script
(random test cases batching)</h3>
<p><strong>Reminder:</strong> compile solution code without local
flag.</p>
<h4 id="one-liner-validator-script">one-liner validator script</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=0; i &lt; 10000; ++i)) &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;#<span class="variable">$i</span>&quot;</span>; ./gen &gt; ex.in 2&gt; ex.ans; ./ex;</span><br><span class="line">    diff ex.out ex.ans || <span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="one-liner-stress-test-script">one-liner stress test script</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=0;i&lt;10000;++i)) &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;#<span class="variable">$i</span>&quot;</span>; ./gen &gt; ex.in; time ./ex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="other-linux-utilities">other linux utilities</h3>
<h4 id="generate-strings-from-devurandom.">generate strings from
<code>/dev/urandom</code>.</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tr -dc <span class="string">&quot;[a-z]&quot;</span> &lt; /dev/urandom | head -c 1000</span><br></pre></td></tr></table></figure>
<h1 id="reminders">Reminders</h1>
<h2 id="checklist">Checklist</h2>
<ul>
<li>data type</li>
<li>overflow</li>
<li>typo/logic</li>
<li>special cases</li>
<li>cleanup (multi-test)</li>
<li>bounds</li>
<li>memory usage</li>
<li>file IO</li>
</ul>
<h2 id="coding-vim">Coding (Vim)</h2>
<ul>
<li><p>Since it's auto compile, never blindly <code>:wq</code> out of
vim. Instead, see the compiler logs.</p></li>
<li><p>backup source file before massive modifications.</p></li>
<li><p>use vim with a calm mind to prevent disasters.</p></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Divide and Conquer on Segment Trees</title>
    <url>/2022/01/15/Segment-Tree-Divide-and-Conquer/</url>
    <content><![CDATA[<h1 id="线段树分治">线段树分治</h1>
<h2 id="实现">实现</h2>
<h3
id="动态问题元素存在生存周期无可减性的区间询问">动态问题(元素存在生存周期)/无可减性的区间询问</h3>
<ol type="1">
<li>使用线段树上<code>DFS</code>(<code>CDQ</code>)实现.</li>
<li>将元素按生存周期拆成<span class="math inline">\(O(\log
n)\)</span>个/将询问按下标拆成<span class="math inline">\(O(\log
n)\)</span>个.</li>
<li>需要支持元素插入/回滚操作.</li>
</ol>
<ul>
<li>特殊情况可以使用<code>BFS</code>,需支持对<code>DS</code>统计信息的重置.
### 静态问题,难以删除元素 例: 整体二分</li>
</ul>
<ol type="1">
<li>可以<code>BFS</code>实现</li>
<li>将询问按下标/值域拆成<span class="math inline">\(O(\log
n)\)</span>个.</li>
<li>需要支持插入/清空操作. ## 按问题类型 ### lifespan <a
href="https://loj.ac/p/6515">LOJ #6515. 「雅礼集训 2018
Day10」贪玩蓝月</a> ### 对询问分治 <a href="">ZR #2180. 矩阵</a> ###
parallel binary search <a
href="https://atcoder.jp/contests/agc002/tasks/agc002_d">AGC002 D -
Stamp Rally</a></li>
</ol>
]]></content>
      <tags>
        <tag>divide-and-conquer</tag>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Set Power Series</title>
    <url>/2022/02/08/Set-Power-Series/</url>
    <content><![CDATA[<h1 id="集合幂级数及其运算">集合幂级数及其运算</h1>
<h2 id="集合幂级数">集合幂级数</h2>
<p>对于实值函数 <span class="math inline">\(f:U\rightarrow R\)</span>,
定义集合幂级数<span class="math inline">\(F(z)=\sum_Sf(S)z^S\)</span>,
其中<span class="math inline">\(z^S\)</span>满足<span
class="math inline">\(z^S\cdot z^T=z^{S\cup T}\)</span>.</p>
<h2 id="位运算卷积">位运算卷积</h2>
<h3 id="fmt-子集求和">FMT (子集求和)</h3>
<p>按位分治</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j += i * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; i + j; ++k)</span><br><span class="line">      f[k+i] += f[k];</span><br></pre></td></tr></table></figure>
<p>FMT 满足如下性质:</p>
<ol type="1">
<li><span class="math inline">\(FMT(A)+FMT(B)=FMT(A+B)\)</span></li>
<li><span class="math inline">\(FMT(A_B)=FMT(A)\cdot FMT(B)\)</span>,
其中<span class="math inline">\([A_B]_i=\sum_{k|j=i}A_kB_j\)</span></li>
</ol>
<p>### IFMT (子集差分)</p>
<p>FMT 的逆运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j += i * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; i + j; ++k)</span><br><span class="line">      f[k+i] -= f[k];</span><br></pre></td></tr></table></figure>
<h2 id="集合幂级数运算">集合幂级数运算</h2>
<h3 id="集合幂级数按占位拆分">集合幂级数按占位拆分</h3>
<p><span
class="math inline">\(F_i(z)=[u^i]\sum_Sf(S)z^Su^{|S|}\)</span></p>
<h3 id="子集卷积">子集卷积</h3>
<p><span class="math inline">\(H(z)=\sum_{S\cap
T=\emptyset}[z^S]F(z)\cdot [z^T]G(z)z^{S\cup T}\)</span></p>
<p>注意集合不交的条件, 可以改成<span
class="math inline">\(|S|+|T|=|S\cup T|\)</span>,
于是利用占位幂级数进行运算即可.</p>
<p><span class="math display">\[
\begin{aligned} H_k(z)&amp;=\sum_{i+j=k}F_i(z)G_j(z)\\
FMT(H_k)&amp;= \sum_{i+j=k}FMT(F_i)FMT(G_j)\
\end{aligned} \]</span> 交换求和次序, 对<span
class="math inline">\(FMT\)</span>数组的每一项独立计算.</p>
<p>记<span class="math inline">\(f_S(z)=\sum_k [FMT(F_k)]_Sz^k\)</span>,
子集卷积实际上是 <span
class="math inline">\(h_S(z)=f_S(z)g_S(z)\)</span>.</p>
<h3 id="其他运算">其他运算</h3>
<p><span class="math inline">\(\exp\)</span>, <span
class="math inline">\(\ln\)</span>, 求逆, 多项式复合等运算,
和刚才的分析同理. 对每一项占位多项式进行对应的操作即可.</p>
<p><strong>note: exp将联通图转化为有多个联通分量的图,
ln作为逆运算反之.</strong></p>
<h3 id="关于半在线在线卷积">关于半在线/在线卷积</h3>
<p>注意到<span
class="math inline">\(O(n^2)\)</span>递推的方向是集合大小不断增加,
下一层的值由前面层的答案组成, 天然支持在线.</p>
<h2 id="eg">Eg</h2>
<p><a href="https://loj.ac/p/6719"
class="uri">https://loj.ac/p/6719</a></p>
<p><a href="https://loj.ac/p/6729"
class="uri">https://loj.ac/p/6729</a></p>
<p><a href="https://loj.ac/p/6730"
class="uri">https://loj.ac/p/6730</a></p>
<p><a href="https://loj.ac/p/2340"
class="uri">https://loj.ac/p/2340</a></p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Set Power Series</tag>
      </tags>
  </entry>
  <entry>
    <title>ZROI-220108 (day4)</title>
    <url>/2022/02/25/ZROI-220108-day4/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="invalid password: the the correct passwd is likely to be 114514 characters long (or not?)" data-whm="decryption failure">
  <script id="hbeData" type="hbeData" data-hmacdigest="5b3261843cf7183e7527e2d268599a093eee4175a0eb578b0cd2c1daea6062e3">25d278611a114276cd8f63ab05488a4e88b8b7499f643e20d7df8c8f065307bd2996c8485f0f5c39789cd01f998e4e5e97a4e59a3c7c0283ffaae709ef5d2ee8784a6e5dcbf94486dc8baf8b47866ebd254b58caace47dc074ffbaf05346d78d6a2cb22ced2db514c8f2d11adf55cb17317c7ab0360f2d5da738e1fa402c95671755e3f12a1cc604af18feca9778135abb647854691b0cdf7c5290481270a9fb23b7dcdecf703f909de475dca25cab53415915f61e02554d8276dd978151167d7fef9430c6591b78b349fc562c768dd238fd5b087e64786175af376edc78b398f52736977984dad9093e65693308e9313045155a35a0f0f87f3e1b5b444a707d8d3a980df4cdb1fd8879988ccba3c6ffda2469fad2b53dcf2d43969d821a45bdf39eee87260e4ff55520fda526f8ab2023c3e0713118c1104cfcbafadb03bf1676974afb97f194ed269318eb600880c133a885d21d1760c1355ccf3b58b77cf0b1730899f1b2f62aadff92c4789fb54aaa681342c809632ab9c7a448b9d774505129b6d342e03f4902b37764746a153de5c961d6aa2d5821ba62fc10cb44f5d6f019d2f5d1b9d5652ef50dee4f7c7eb00891dd3b2eaa70fdc09bb2153d130c807d6436283a12abbd8f41e17a5048dd7985fcf6d4443d2f0ee4cbcc1ed3dc909d2b283a45191356a371c010e32f61c6419b4d5456170e94c46a50b28f2f656b49e99c9f00e1914f194ce68735c40069558ff9cce95568b9c4bc69560266577b45244fc7668444625af7199bf8e8b5c6e28418f25fee3b996ca5ce576c54dc8d8ba454370be1625ca579b02d7046f0aacde1e4ec14fb79e51b6405cfb9ff82d6175e771c00b699d6bb5b535e97f5ad7e19cc975bb25c67553850aff406e78b71a0a0282cf694ba04434030f555fd2d1e65683443bc9528bb64b99c68dfbb6c8f583dc3179e9bb12f52477bf4a4465d671c7b92260eba9deda2263ae9b33a095734fbd1c9fa49720cb41276302f412c20c7eebe9e8ee2bbc689620936a7a06525cf23f0d94e1e49b91852a6a6df41656f98a07b5a86b95db37ba13c5283331939367d4e8f0f88314ece1f53c7a0a950cfe5197f43d70a644a06619575a87b667c798dfc2825245fa09cc60ecb33be8b4ebe2560ea8c1f06d1301fc0920801ab685a352a10390fcea238bc83a174c9e3ce42bb7c480d37277b9047176989ef3f4fd66f6be914eb1a9f2f7eec3a65954d996f48af86c18de6335194de640e6ef5b735711341794ef1aee260386212c0b708af8bb2507111fa56d776e7fb5dc8ce352fad947958cad36781be78d2b2c3756775d9939b0b00c5227c8f89a9c3f5fd090e7d56aa936a8b34be38068e03e892e40755a5cdad101faafdfc90868f5e0e138f4e0ef90cafcdb27e83362d67dc8bba327e46f2d4266fe654e608b9d1f177a042ebb3a5f6a2a67c85cb0d341c261f362e4978901606e13b9b5a2c66e788600a5c842c3140fcd75558e308149dad5f5a7fadbd575405ba47f20a75e93aa13b6ece4556695c5c365c75be37f5b4e9a8e75f01f53c954c3ca175ac8a731cdb7f92819fbaeb1b4738eaff073e431adf5b655250bf4e642eefaee558ae9db0221abb7b66a01cc8109b36099ef076ca17aec59bca54d7b9b68ac003a2775cbd1e7c7e3ca4ad02f53d6615b411d28b149d413975b9f4a5913baeaf43965e702e8ef293ef4fb3f774209ae468a0a15d450a5b66c367b446c1ca6578a2e37a4d37fb8cd7140db4ad492935c0b8a046bf5127ff07c127269c7beea0c0c654ff5745569ac79e0eb631ebb39b467324da1e2c6ca26a604950d84a2e8c5036b234e8fb93bcadd1e7e78d2056ab2a1efe7a7a02e356ae295a486bfa1bfc363783540e94d6596d7c032d8e33c94ff17ebc33bb02ad64b7400c8f597748f246ce1cb2c0952263ec9d0b7078657e81cb52bb82093ed62949102d900c6e8888dc82bc77b458ef3a4cb6717c2a79220c04877e4ae8c08817545870a37e389f16fde2b8b0b11614c329e87eb51ba0f02bd0403f29bdd365e633631b9b625531679a4bf2897ce92fbbeed6f744cb114a0090b350ad961cea20d66486c69f4528d45d6b48d30b252c97c6a4058d3932cd0df51eb2f5eab42e5c6648d9dc2d1f855d980c178de22c68799cbfccd13d4a00bf1dd4eed0e9c64ce403178e4b019f66866110871eb6e9ac5190ee852d9758a1ac3c389c8c926e74bc0534230727cb9a59d0ae5277366c87e0d8bad4d80217d1afd388066c267d9d01cc44e55bcca0c111985d9c27319d524497b6fe326c3490828e60aa10d12207127036c18485b2599061bc512ae426331abd8661b96d46c674a7560e2a8c7d369a37cdc9f0ddac7b2c055db95b57f516893d48d9f2394fe7353c7984a6feff6240b8f71d1fd3befc20d3a3bad97a91ca09d00fca1610686dce836dc6f5b4a26ec2ebc93090b993b5663f395da7b85da50d0af0c534707f0e289898eb686b5ec276958d426358f695d809f58db26664430b62bed1b6602100fe42402ba3120b74a2203777695b0216daeaeb7c68c6ca6dd1b45c339911296355affb938f480c60420638f3621fdbdb14598dd5fb1bee6e317802c7f57fd2f39082961583faf17881c5812b579d91e181842c2a1db0959405e06380a68dd7f8c395524c9151c4e79337afb17a90b405ed59732711aba888118effce4c32aa76cbeff769e757f4baf6d2a82d5ff85d052b8ff1541855630a8901f685c6b3a6e1d36fa48aa20e1591eac9154fb35fa370ad6f8742664bcde22bdecde1dee509935cbe21b0a1583fca191431f03a2fcd1e522fb7eaae2ea11ba3bcf0aed9e1c689e01e2d19ac1d3290d539c8ceb31235d361870e199f03c32491dffb4d1540a14ec14f784992ab940db5a3bf1a72fe235c1f7643d90dc3c5778ac8b8e023f3f1ba280b093e73c37dbaa1ee2831a8ecc22ced2fb36db9450f9d0529446ace1b3401460f4e708a76ec12cfa75b91697ab12cb755e3b49f37affadd65a0501a08fd5ee6dc11e696f784df5430df3772dc8a249a47293adbcf76f54e78388a0607e125a92644b0b4f40197fbc9e944f5cb1e8571f045ab1cd70a72dd35129c51d34d9ed46d917a24895d3a0de9e05dd1f36c5259d8e43f0440e81028528cbf45e6d35dbc473c0b58e02749c55ccba200df2853e705c13f856b54bb5d0631766e3b860ffef28b292d85d88176f95ee733cf63e25f15e94e7a71ec9cee6b64c4769d5b6591bf9500a242954776482560e44812486551caf26fcc1980637630d54e54fc83a941334c64b4c66d3a1531410e9b99e3ef8e92df902ede9a76f40e2a2fe7b94e28f3ef680ff206007d9a508ca739226cd3e290a415cd9e4d86e70821314c66b6098964d23ee10785e34ddebaa33d3278519d45c355b6d18c3e86a8dd7809a966a60e00008301c02a26f03c441c1c57d379ac5269ff7151b80eac5e2381a1c9a81f6647ce1feeb81a125e928bc386868655ba06e95160020a0877cf438baaf583c361279bf5d07693d4d0c8bb962a8379b440c2e5d1fabcf32554c10f2ace6f6ef39fd54fa1c97ae16595779178d2dbf347fa4bf2db28e2d08b74022dfdac1311c0b44ed385d447a255f31ff549ab8033502f901d8cd47450c1ad2336e16995b0169960463b2796cc1424402d30ed3a99a1e5b20850add5282be2735724d4877aa3f3c933a8acec0e1c54ff913ce19e0d46a1df5ed38276b93ae8012e1c81449c2a7e476105fd9991adbcd0f8f91c6e64e28d5feb850002a5572035176029fb78f66b525c5ac19d1b665df945e4dfadf8455ce8435cbf67375dea1ce186a4b7df36526ab2e5edbdd7f4bfa70abd40eae2544c1720cfa2d6f3adc40abacf3265366edeb15121d305946428222ed4493e20487157ddc6a923ec14e66416cad5fe86396d3beeba56dfc97413780424a5c91593ebfedc5b2bd88cf97a73db6ac0ce12ebcb0e07fe8b0d20bcf37a6cbed469b319c8395376e5a759d50afa2c1bdcc4c9a968ac9cc2362211e1adcdd8e19dda2990be28b2588b14851dda5cf8206985081567f56e32b60fe401184e57adf7e197656a85087d070e1c14d46259b803d47bd35ebebe3492c9bf514be6e1a8a50b586f2be54ded34f9976729d648dc85cae2d700535babced46e1f78fcde4e118fb8357985abd33eba5f55bf618a0cbdcc273b16943eeb7ebcc1fb21f3922be78a16b8aea404e368da50adb245bd64f75cc343c775f7f1b08193b0268c2389301b9bfe2707de416cb30c6c8b3cc45e343b1f09ec6d779b6d6a212045a1caf061025954a12832929e6e35c2cec5516762947a3135baaa27547094fafda169fc9f31dfa3ed0de42ca6d54ff0334589ae205f27098c551240363d22899b99aeee3b828bf181c79aa2d6133c52cfdd36e743ae8bbb1aa67c7711eb7ad4e8e7fd340c603ce3a6cdc13b2f9342899e217c16438657c4b8fcbdce2e738bb917f81deefa15e6b52ae29db6e411e4193262f99927088e598877a4a060c67d3db6bff7df0fb78e4853ec609d303a8d16c855a5c0ca2094afc5dfebce6e602883be47b86b41a3ebc0e2a5b3c3d0586077ca0b042bb5c8c6cd81afdfe6f449037b9e5d53d26a384d32890af2b0298c2316459ec88e9b8fcee56b1053c7b41071c71efae847ef84b3ebdd09395f6b848dd41933fc55a85dc7e1992a89b4bc834d827c1b8b400e9e07fccc20d9a4bb5cc994ad3571e296c6b7637915fe848735919c3e79e7b1f4d578451b2305d7a5a1f278003be09f679440ef891f5374d7861525a80f4cc2bd6d1fc6790089972c2a453a5ecdc100aade638db1af311ae7ce0c4554beec487caa687a8759830ca5dd029bf1c0cef1f44355e034ff0906c5fc96cbe77be12dd8f89d61d326998dbf457919223c782b8948a299fb3caf3f46eb569ed4bbaddb363b0b5a3492737312f3e77f700353eef48a7047c747bc2122f301183a92db82ccfe73fa6d9536475602bbf97768525ca3d8e6b523c223c607bddf932a6f79ade40f13c8813df187297df0f92e2d03d4814b9f0f0320e85abae7440b0668d5b7c84ff0419dfecc1a8653a6aef9d0c7ad168a13bd39d2bc4b3bc50fd88e932f5db6a51fca97ef817135899dad5a2ea4caea1a260beec56e4642e9fe01f66faf99d0e2548082bd856a8d7dd6ee2e8a2047cf227231e65177e597f89e90d4e78db78d6dcfca4976645679fbb6070f7b41b589bd9f6b9b21c7b92256ae3ab20b47be80f293ca706f2f3a454d0458e35fc255fb224dcf95d5f6b5b9f46f3032dbe5a95d6330213f0f3dc6ca840b461fd55a3e488e306dd701cb8286a399cafce515f416891c011fca63b2bb1f6fd6fda4cb34f3910e20811e2a5e75656b4b54bf2087ef9f8521353b7c205a2a55b2a9ad9411cefe7631f43603978cedbe6ece75a0accc913a5ed4d02f09cd662733650ab59e705de42660844db13d70b4053011b3021a65eb6b67d962201c40d48e6080f667fce78db206c8903f80a1f784ab993a684767d6f733d200e3a8de494fd8666c7f8977ca99e9ccd0de58016f1a53b20a60406ee6aad5d6f271d2e1c0dd25de1b688c5692803b7cfe6953feaf0a85d3b520700e157f26c7957609cc9a7bbe4eecd3cbcb98ebcc23f904ff448163e1c3c5c88d0bf375ccf7c9afd4cdc8f0c77c5dd2fdfbf2e6523300d7017bee102c316f430fbaa4b5444686bc66f7e3f1313ca017e4ae8778de5c1e734c6ee837e552b681d5a06a7cd8b0389f18c39edfbbee059a772fbc3cfa90209d53f7c31c21fe526ef818728109760760896310e8f59c0a4703f75eae0e3f7375ec0bac7041b8a246461ae201d08e2880ef0f33eb2bdee92cafcdead992fb41eafbb5e2f729aaa5bf581a9fc478a9aecbbf076576609175ce6067159da3878ad271b0ae8e4b9a26da767a98b1ee40dfe70905b255c2c9e6fb32a24f5832509127585ad31077502c8389879d19750c6dcbdf854b916fccf4e7c598dbb782edb189b7e7201bbec227066b0d9f733e30e9764550751616fedfb4ec07f3e0cd3834398b51ae4000cd13448de82f91b47452a864f9c5a9726f12f28bb443c5745a5d13b3287e96a052c61a38afde033965ebd070da1fa84b5d7ab4fe3b0f2129c06b9b2c3ddbac2ff752343395da9333f0ef401988f05793bc36f5d66caca8db0e58518f4dd3acabbc520e439a5262fa254fa4100afb9e94cb3d9c0e44bd2eaf5fba192b8dc682cbbad601d9911f2da31661f12ed00e9f26dfa75c1fa1b353167433ecc457177e461a18b63942a2dc17e0b6f7ce59a1a243ac0e42f1ddb36751d4ba8f5ea41fe62086479928e0584c3b8a9edb2d7ce89ec7247a93f3fd29d00126cdb84773cc8e9ebbc06027c294e8cad2455a680b4461f76d67763510185016f92cf14ef4ec29d18c8b1f59c503f1100ba44e3a81b5392c556c289041de284cf96128eeb033339f2932ee56feb38c1aabe51bbe2e63df1a42c6e63e8f5f6071dddf745b8acdbe67eed5137fd5a7da29d800cf9abc6074254e50e7aae697b925e079c021bf04ac6fe3ffa8abe19b4bfbed6554edd08f92a433134b1122e7f666ea5533fe63ac4ebdeba68b42c6a3104ed0e2b19bc21db9ba22309865b5e23c80b7a3ca234e5c5337a024a524fc7f01a62c26e34f7255438636105d45a7178a37b0cdfc07e2fa58bf3630b4a1b28b22904e9cfbce5a8297bce38b19901334d8aa33355155f40711177ae6081468e3a60e01fdebf690339ff6e946df6c2fffcf915e69f7dd89d38eb01364dcd537dfba6cb4d958c09f657699909aa2e5e17897f80e8ac63eb4ee6dd9e91800ad9685bfb31d29f103f121984bfdfe5486421019d41b0f2e6ff3e84b77e10b9003bc189d66d6d750ab06d3b3eebcfde775ade60efc67badb0a2cd1f484b5d56bff1a2c6cb4e2a16ca2943a95c166b0473251a96629be702d6ecd8db7e1a85182578925a84d5ae639f1404e517508a6010af29833e4424038bcf0336821815ceefe4e26c79e393809288af60391f92f882c43da1652cc85bee92d46547b9576acd3c4051ef46eabac71a380894ff8cb0a04fa87d710a1cf5818878a54dfbe</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">$ sudo decrypt</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>ZROI</category>
      </categories>
      <tags>
        <tag>Network Flow</tag>
        <tag>sec</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>fun facts about sequences</title>
    <url>/2022/02/15/fun-facts-about-sequences/</url>
    <content><![CDATA[<ol type="1">
<li><p>一个和为<span class="math inline">\(0\)</span>的随机序列<span
class="math inline">\(\{a_n\}\)</span>, <span
class="math inline">\(E(\max_i(\sum_{j\le  i}a_j))=O(\sqrt N)\)</span>.
常用于<code>DP</code>, 通过随机化降低时间.</p></li>
<li><p>任意一个序列, 其中满足<span class="math inline">\(\max(A[l,r])\gt
\max(A[l&#39;,r&#39;]),[l,r]\subsetneq
[l&#39;,r&#39;]\)</span>的极大子段个数是<span
class="math inline">\(O(n)\)</span>的. 求法: 单调栈</p></li>
<li><p>对于一个排列, 对逆序对连边, 形成的连通块一定是区间.</p></li>
<li><p>一个在<span
class="math inline">\([0,1]\)</span>之间随机的实数序列, 长为<span
class="math inline">\(n\)</span>, 则第k小数的期望 <span
class="math inline">\(=\frac k {n+1}\)</span>.</p></li>
</ol>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>observation</tag>
      </tags>
  </entry>
  <entry>
    <title>passwd impl test</title>
    <url>/2022/02/25/passwd-impl-test/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="invalid password: the the correct passwd is likely to be 114514 characters long (or not?)" data-whm="decryption failure">
  <script id="hbeData" type="hbeData" data-hmacdigest="d97777e0a0269256b4ab19487cd90c3f757a3cc6f9d62965b74434d90b1a142f">25d278611a114276cd8f63ab05488a4e88b8b7499f643e20d7df8c8f065307bdab8baf06ea0148894fb2cf77c163465ad97a481021c1cba426267b725d3eb6fde9cba75cd36731555e8c5a1cf9a95023a576b7c458636ac6b4037b31ae5dd0cf26f11b72caf191db960f1a5ce245788fae468610795f44ea4d5dd3c5ee1fe2ec150e36154d509d7d0f8ff2c6cd786040eed5de8f8299fc2a48fbd8d1b76d100eee34bfba92f3985c0c56b553561a93394790f07c75d34d35a3d90b1d7aba67c8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">$ sudo decrypt</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>AGC020</title>
    <url>/2022/03/02/AGC020/</url>
    <content><![CDATA[<h1 id="section"></h1>
]]></content>
      <tags>
        <tag>AGC Series</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Regular Contest 136</title>
    <url>/2022/03/01/AtCoder-Regular-Contest-136/</url>
    <content><![CDATA[<h1 id="atcoder-regular-contest-136"><a
href="https://atcoder.jp/contests/arc136/tasks">AtCoder Regular Contest
136</a></h1>
<h2 id="b---triple-shift"><a
href="https://atcoder.jp/contests/arc136/tasks/arc136_b">B - Triple
Shift</a></h2>
<p>In this construction, parity of the inversion number is an inveriant.
## <a href="https://atcoder.jp/contests/arc136/tasks/arc136_c">C -
Circular Addition</a> cyclic difference.</p>
<h2 id="e---non-coprime-dag"><a
href="https://atcoder.jp/contests/arc136/tasks/arc136_e">E - Non-coprime
DAG</a></h2>
<p><strong>DON'T resort to flows, math is the way to go!</strong></p>
<p>try analyze what it means to be connected.</p>
<p>Base on the fact that every pair of even number are connected, and
the distance to any number connected to <span
class="math inline">\(x\)</span> is always greater than <span
class="math inline">\(\mathrm{lpf}(x)\)</span>. a simple casework
reveals the exact constraint.</p>
<h2 id="f---flip-cells"><a
href="https://atcoder.jp/contests/arc136/tasks/arc136_c">F - Flip
Cells</a></h2>
<p>PGF magic.</p>
<p>Assume the process never ends, let <span
class="math inline">\(F(z)\)</span> be the PGF formoving from initial
state to a valid end state, and <span
class="math inline">\(G(z)\)</span> be the PGF for moving from a valid
end state to another(note how the initial state is irrelavent here).</p>
<p>We have: <span class="math display">\[E(z)G(z)=F(z)\]</span></p>
<p>where <span class="math inline">\(E(z)\)</span> is the PGF of the
game.</p>
<p>The answer is just <span
class="math inline">\(E&#39;(1)\)</span>.</p>
<h3 id="details">details</h3>
<h4 id="derive-fz-and-gz">derive <span
class="math inline">\(F(z)\)</span> and <span
class="math inline">\(G(z)\)</span></h4>
<p>we first calculate the exponential PGF of <span
class="math inline">\(F\)</span> and <span
class="math inline">\(G\)</span>, then wirte them as the sum of a bunch
of <span class="math inline">\(\exp\)</span>. Finally substitute <span
class="math inline">\(\exp\)</span> for <span
class="math inline">\(\frac1{1-z}\)</span> to get the ordinary PGF.</p>
]]></content>
      <categories>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>casework</tag>
      </tags>
  </entry>
  <entry>
    <title>ZROI contest day6</title>
    <url>/2022/03/01/ZROI-contest-day6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="invalid password: the the correct passwd is likely to be 114514 characters long (or not?)" data-whm="decryption failure">
  <script id="hbeData" type="hbeData" data-hmacdigest="629c7f4ca011397f4a36c3d93aa309c1378c70d99d89781651458f53f435bf8e">25d278611a114276cd8f63ab05488a4e88b8b7499f643e20d7df8c8f065307bdb877766cf29b866c16536d079d62d499a852ab143b3bf5d53d98df78d223055834b4fd3038b362ef5ecde659025545d2571d26d70cc469f1553f4d7096a3ca438d1fc24a0cda24475529ac3eba5823f6cfb251dd5da8d053a9d642a72ffc1b218f37658d5f94d5bd4bb8b1dcfc4ebc21fc11b02489bfec2acab5d3c41a4683961303b10bad20e5a49d5202c85755bd54bbefed33205889fdde473a61dc6a4fbc384c6d3f1e5a99b1f2f7708a7863ec3550d49e34c076f675a1b362ba373a075607ce6af6d0c9fad7e6e223a5e6266ba128d43e05a1105b24c937b99a0829adb782e292d26867fc4314a7e9917f94af5719cc41f9be28460630b1b84186b1e7a1630cf157b499734313f532650b86dafd7b9379dff29d6f97a90ae5190531e282b760ef6bddc072f44761a4360594c1635ec095d3a45f70df4e831202b3c24cd3ec48b8135c926d5897454ce687b18872aadf116cec9aff3679661dc8007b2b12db8f31b57d9b2f7d70e404dcb9c483ccc951a38ffb67202321be61f8a2a616e49acd497b9af459160fb73079335054d561220697f2abdf60cb3052fe1461ab4e55896a5b0121af8e6806b000dcf80c7864156be72ec5ca02af083ce49b54d927f4880084b4360c61fb5d8094ded6fe4be337f1ff6e76e26b19066c85d73d8dcdc2ad6705bc2ab37e5568a2c18253574a4e90f8ac669242ba63d41ec40c35cfe38c42f69b65c9dfadc0d8ad7c4f466709d4d35a960bece47fc2980bca1f019938f25870753768d449013ffb06be777ae5c070971fb06540c22036006dba14175b17ad5cc963653cd2fb0c5589b9ca9cba5d2975318b7de45877b71ae307eddcdb86ab357298717de1f2a146cd0a68c704cd48f16f866e66d35431211e93f58952a0123af1b84bdcc50841eba774472bba3ae339d31a8d2e2a3437ce70c5512365367052b3f1271af0a41fa0483d09d7d50896664c96dd3fd92e7711e73fcd0beccc2b1ddf7e8878beebcf9bc9be75c2933f0d0b7e14a52e4c39fc86a7af5da67759f0f8a6227e2e0374fd5e9fd9d6b7bbe7907cfebf5c95f87273b6cc1f9202995db07fbc1ca69f4a6132f7d30265542680f8880bfe2c778a8e11c82609c83f3be9dc699ee152c6f8922b1dfb5ef90214d23a083d86e24d55340031053bb26f5281c7f3ef81b1506f23d97325bc78132b98ce9983c62658e50d756316589ab260e120bed0dce16892d89b1b6ed3bc247e2de14f8ed6653e3742cbd51fed9e98940f061a101ec1a7e4dc6166c225d9a4e1de64af87ef4316c920cf05268f8e222e4a08114b38649e3425459544ebe0f34242272824a4c4bc5e276569d10db6d50afaed4652a502d07f6388a70bf4cf026ed1a94bb2145281d60c342fa3a3a58e26d8f58a805a2fa7110209abe341eae778520eed4231b3946fb01dd228fc80e437457c062dcb03970f381eb2a0d8d52918592807b6a4759669aed2dd77c2109f8cf1e45defd8193a983661d096846c807fc334266cb2c84420c2be43732207a9f5f454ff175abe53bd3dc1ec62429da4b0f2b46039fa92d7193b30fd9b71b4a94d217a819441fa7fef80a24e499a1b557510a4f72145125c953ef71dbba44feb93dc451955d93764f232ad4c0f273f3ec114edcbe59b06e82ea46c54c5b65df9e741b19e3f7875e227a557c325f5b0f677b86a078bb1affd26d0e31d0e9ec5631e36038b41d8df1508b4ad7d6d3941ffc1386226af6eedc08459c04d8972058ca97650989e18fa4d7815fa61d166fcfc3e362b5b355334eea5571704dd0f4f196912d63f2080fa78f194bc7d055e4137a6ace3ad27a2c4e195c2871b011153f60c0bb2f380d3d7770556e13d8c0ff36e4622bc50c875eab8a6bf9ba551933eac1f8fb5bffa0448c239c4fd7f8475a04927dc96a229b78af3747ff07adf52372c5cc61256c59f55952cd781a27d1a9771685f5ee7a6c171585d5ceba645256f3260c69ad96bd508f37678597281f9f708de2d842190ec6f4e15db8b088382fe0e72c05a96144c253710f0850fbaf51800f701bb682894a856ce251281d0376054a5876ed346426ff151df02023f6e084796fc28287c6cfd425ec08ce6aaf98ed163af4c43499763487f2b7f832f907a02253ffd91d68a892cfd8f275d2f082f5724a180197c127a2b8d2686cc3274c91636bd427c48a30abed1da800e247afb867c014a1bde2df1eb879818158cd770d7978568c67c447dc578956c3fa77b2f6e71de885405e1db84b8766e93b4a8516abc16a769a5cd0c1485d4df38d4b5ea416f767307f848a87043fa2c226da431eaecefa5b1d85ac5df89fa032a03c783dffd18f6973b580c447f564d1bd42eb1c6224925f9fc236e4ef9e0033b0771a24eabf2b85e37cfcf05060a0be2c39a51d69a70d6d0534c44399efe3808741804f4ccc00dd2725a22393ea8b38f60dd798d0989752f1f42458cb5749cde1bb219b21ece8bccb9855b98ec1cac4d463de469b905c351567166e730a40b1767c6bf47224bfd2d4f4ebf6bfcd631c00d823e4c48002370d4852f35a0b15985a64b8d1d55a8990ff1a00ded1b7e4b9e1a49696c5a166e45e643c1ce3db02f8701d054e7a9cc2678e89d3e0738e676bc43ac56e1fbf008080a66ee5b6dbf7fcd6ff8f5352ef33c7ddec180ff23b553d7a0df549027e146e55438bfc840fcd1d178dcb80548df976d8bcbe9f1637aa9eaa8f7e26d388a68d5f6552069b030e49cb8631c27b4</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">$ sudo decrypt</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>sec</tag>
        <tag>sweep line</tag>
        <tag>difference</tag>
        <tag>elimination</tag>
      </tags>
  </entry>
</search>
